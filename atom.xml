<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wr4javaee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangran.me/"/>
  <updated>2018-10-19T09:43:32.000Z</updated>
  <id>https://wangran.me/</id>
  
  <author>
    <name>wr4javaee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud Finchley 在业务系统中的实践总结 - Zuul的实践与增强</title>
    <link href="https://wangran.me/2018/10/19/spring-cloud-zuul-01/"/>
    <id>https://wangran.me/2018/10/19/spring-cloud-zuul-01/</id>
    <published>2018-10-19T07:38:00.000Z</published>
    <updated>2018-10-19T09:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　本文主要针对Zuul在实际业务场景中的一些实践心得进行总结，重点围绕Zuul本身关于动态配置缺陷问题、老项目接入及老环境上线问题等方面进行讨论。关于Zuul的一些基本用法，可直接参考<a href="http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html" target="_blank" rel="noopener">Spring Cloud官方文档</a>与<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul Github</a>。<br>　　我们使用的Zuul基于Spring官方目前最新版本Spring Cloud Finchley.SR1。</p><hr><a id="more"></a><h2 id="Zuul是什么"><a href="#Zuul是什么" class="headerlink" title="Zuul是什么"></a>Zuul是什么</h2><p>　　Zuul可以用两个单词总结，即路由和过滤器（Router and Filter），它是Netflix开源，并被Spring所集成，成为当前Spring Cloud最核心的组件之一。它的基本功能可概括如下：</p><ul><li>认证鉴权（Authentication）</li><li>审查（Insights）</li><li>压力测试（Stress Testing）</li><li>金丝雀测试（Canary Testing）</li><li>动态路由（Dynamic Routing）</li><li>服务迁移（Service Migration）</li><li>负载剪裁（Load Shedding）</li><li>安全（Security）</li><li>静态应答处理（Static Response handling）</li><li>Active/Active traffic management</li></ul><hr><h2 id="为什么要使用它"><a href="#为什么要使用它" class="headerlink" title="为什么要使用它"></a>为什么要使用它</h2><p>　　路由是微服务的架构体系当中必不可少的一部分，那么缺少它会带来什么问题呢？这里以公司某业务线实际场景为例：<br><img src="/images/15397653100461/Spring%20Cloud%20Zuul%2001.jpg" alt="Spring Cloud Zuul 01"><br>　　上图是是一个简单的前后端交互架构，来自PC/微信/H5/IOS/Android等客户端将请求发送至Nginx，后由Nginx反向代理到指定后端服务集群中。我们能够很方便的为后端服务集群提供负载均衡，同时通过Nginx的反向代理，可以隐藏后端真实IP，即提供了一定程度的安全保障，也使得前后端服务调用隔离，降低开发成本。<br>　　随着业务规模的不断扩大，后端微服务已从数个服务集群扩展到了数十个，此时Nginx为每一个服务集群都配置了唯一的域名用于反向代理，每当这些服务集群需要扩容或机器迁移时，需要运维投入大量的精力去手动修改配置。此外，这些数十个域名也造成了资源的极度浪费。<br>　　<br>　　<img src="/images/15397653100461/15398454116261.jpg" alt=""></p><p>　　在近些年火热的微服务浪潮下，我们都热衷于将每一个原子业务单元都拆分成微服务，这对运维来说造成了很多压力，就好像上图中，当你面相这种规模的服务集群时，传统的维护手段已接近于灾难，必须要想办法借助更多的工具来帮助我们。<br>　　相比Nginx，我们可以将Zuul理解为微服务集群的一个可靠的大管家，它是上述问题的解决方案之一。使用它，可以方便的用一个域名来替换掉之前的数十个域名，此外，当服务集群扩容或迁移时，Zull可以做到自动识别，即动态路由，它还具有服务鉴权、服务降级、熔断、分流控制、接口控制等Nginx所不具备的重要功能。</p><hr><h2 id="问题与挑战"><a href="#问题与挑战" class="headerlink" title="问题与挑战"></a>问题与挑战</h2><p>　　Spring Cloud Finchley版本基于Spring Boot2.0构建，按照约定大于配置的思想，我们能够很轻易的上手使用这些开源框架。但是任何开源框架放到实际应用场景中，都不可能百分百的切合我们的实际需求，例如</p><h3 id="当前Spring-Cloud-Zuul最新版本不支持路由的动态配置"><a href="#当前Spring-Cloud-Zuul最新版本不支持路由的动态配置" class="headerlink" title="当前Spring Cloud Zuul最新版本不支持路由的动态配置"></a>当前Spring Cloud Zuul最新版本不支持路由的动态配置</h3><p>　　虽然Zuul能够做到动态路由，但是反向代理的配置信息是需要在application.yml配置文件中维护的，这意味着每一次有新的服务集群需要进行反向代理时，我们需要像重启Nginx一样来重启Zuul，重启意味着增加了上线的风险与成本。</p><h3 id="非Spring-Boot项目接入问题"><a href="#非Spring-Boot项目接入问题" class="headerlink" title="非Spring Boot项目接入问题"></a>非Spring Boot项目接入问题</h3><p>　　对于任何一个Spring Boot项目来说，可以非常简单方便的与Spring Cloud Zuul整合，但是官方并未提供一些工具来支持一些老项目的接入，目前实际业务线大部分服务均是非Spring Boot的老服务，我们需要自己来实现这些通用的工具组件。</p><h3 id="老环境上线迁移问题"><a href="#老环境上线迁移问题" class="headerlink" title="老环境上线迁移问题"></a>老环境上线迁移问题</h3><p>　　长期以来前端业务线一直采用的是Request-Nginx-Server架构。基于前文介绍，我们的Request端分散在各大手机应用市场、微信等合作渠道，对于这些已经集成了数十个不同服务域名的前端来说，接入Zuul会有一系列的问题需要解决：</p><ul><li>App端每次更新都要重新发版，时效性差</li><li>App端接入Zuul后若出现问题，无法及时回滚</li><li>旧版本App无法修改接入Zuul</li></ul><h3 id="上线验证问题"><a href="#上线验证问题" class="headerlink" title="上线验证问题"></a>上线验证问题</h3><ul><li>测试与线上环境不一致，上线存在未知的风险</li><li>我们的业务模式，无法在线上环境进行全流程测试</li></ul><p>　　基于业务模式，系统中有大量节点需要对接第三方机构，无法进行全流程测试，同时，当前我们的测试环境无法做到与线上环境完全一致，对于Zuul的接入来说是一个非常大的挑战。</p><hr><h2 id="Zuul的核心架构"><a href="#Zuul的核心架构" class="headerlink" title="Zuul的核心架构"></a>Zuul的核心架构</h2><p>　　Zuul的核心其实很简单，就是Filter，如下图所示：<br><img src="/images/15397653100461/15397741541838.png" alt=""></p><p>可以看到，Zuul将过滤器大致分为4类，Pre、Routing、Post/Error</p><p><img src="/images/15397653100461/15398306875833.jpg" alt=""></p><ul><li>pre： 这种过滤器在请求被路由之前调用，安全与鉴权功能可在此实现。</li><li>routing：通过HttpClient/Ribbon将请求路由到后端服务。</li><li>post：路由后执行，可以接收到后端服务的响应信息，并转发给请求端。</li><li>error：在其他阶段发生错误时执行该过滤器。</li></ul><h4 id="Spring-Zuul提供的默认过滤器"><a href="#Spring-Zuul提供的默认过滤器" class="headerlink" title="Spring Zuul提供的默认过滤器"></a>Spring Zuul提供的默认过滤器</h4><p><img src="/images/15397653100461/15399408807599.jpg" alt=""></p><p>　　Zuul已经为我们封装好了基本的过滤器，表格中Order是这些过滤器的执行顺序，可见Zuul为我们充分预留了很多空间来对默认过滤器进行增强，例如</p><ul><li>安全/鉴权</li><li>流量控制</li><li>接口控制</li><li>访问统计</li><li>…</li></ul><hr><h2 id="动态路由增强，实现路由的动态配置"><a href="#动态路由增强，实现路由的动态配置" class="headerlink" title="动态路由增强，实现路由的动态配置"></a>动态路由增强，实现路由的动态配置</h2><p>　　Zuul相比较于Nginx的一个很大优势在于其提供的动态路由功能，前文已经介绍过，当服务过多的时候，运维需要大量的时间去手动维护路由的映射关系，极易造成严重的线上问题。<br>　　好在Zuul与Eureka（注册中心）在Spring Cloud中实现了完美的整合，Eureka能够实时管理不同集群的每一个节点信息，Zuul便能够通过注册中心获取每一个服务的详细清单，并通过Ribbon实现负载均衡，从而达到请求到转发的自动路由机制。<br>　　前文提过Zuul并没有实现路由的动态配置，每次新增反向代理规则都需要重启Zuul未免有点尴尬，是否可以修改Zuul来避免重启呢？我们需要看一下Zuul的动态路由的实现原理。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>　　找到spring-cloud-netflix-zuul-2.0.1.RELEASE.jar，看一下路由定位器相关实现：</p><p><img src="/images/15239442308370/zuul_locator.jpg" alt="zuul_locato"></p><ul><li>RouteLocator 路由定位基础接口</li><li>RefreshableRouteLocator 提供刷新接口</li><li>SimpleRouteLocator 基础实现定位器，主要实现了路由定位与路由加载逻辑</li><li>CompositeRouteLocator 复合定位器，提供路由定位、路由刷新功能</li><li>DiscoveryClientRouteLocator 组合静态以及配置好的路由</li></ul><p>　　通过查看Zuul的源码发现，Zuul已经为我们定义好路由定位于刷新的接口标准，RouteLocator接口主要定义了路由定位器，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Ignored route paths (or patterns), if any.</span><br><span class="line"> */</span><br><span class="line">Collection&lt;String&gt; getIgnoredPaths();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A map of route path (pattern) to location (e.g. service id or URL).</span><br><span class="line"> */</span><br><span class="line">List&lt;Route&gt; getRoutes();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Maps a path to an actual route with full metadata.</span><br><span class="line"> */</span><br><span class="line">Route getMatchingRoute(String path);</span><br></pre></td></tr></table></figure><p>　　RefreshableRouteLocator接口，只定义了一个路由信息刷新接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void refresh();</span><br></pre></td></tr></table></figure><p>　　SimpleRouteLocator，主要实现了RouteLocator接口，在内部引入了ZuulProperties。ZuulProperties的配置是我们在application.yml中配置好的Zuul相关信息，其中包含了反向代理的配置，SimpleRouteLocator是基于静态配置文件的路由定位器的重要实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private ZuulProperties properties;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">public List&lt;Route&gt; getRoutes() &#123;</span><br><span class="line">List&lt;Route&gt; values = new ArrayList&lt;&gt;();</span><br><span class="line">for (Entry&lt;String, ZuulRoute&gt; entry : getRoutesMap().entrySet()) &#123;</span><br><span class="line">ZuulRoute route = entry.getValue();</span><br><span class="line">String path = route.getPath();</span><br><span class="line">values.add(getRoute(route, path));</span><br><span class="line">&#125;</span><br><span class="line">return values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Route getMatchingRoute(final String path) &#123;</span><br><span class="line">return getSimpleMatchingRoute(path);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　接下来再来看看实现了刷新接口的CompositeRouteLocator与DiscoveryClientRouteLocator，DiscoveryClientRouteLocator继承了SimpleRouteLocator，同时实现了RefreshableRouteLocator。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class DiscoveryClientRouteLocator extends SimpleRouteLocator</span><br><span class="line">implements RefreshableRouteLocator &#123;</span><br></pre></td></tr></table></figure><p>　　它主要增加了DiscoveryClientRouteLocator方法，用于通过DiscoveryClient（例如Eureka）发现路由信息，以及实现了动态的路由刷新接口，这里的doRefresh仅仅是调用了SimpleRouteLocator的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Calculate all the routes and set up a cache for the values. Subclasses can call</span><br><span class="line"> * this method if they need to implement &#123;@link RefreshableRouteLocator&#125;.</span><br><span class="line"> */</span><br><span class="line">protected void doRefresh() &#123;</span><br><span class="line">this.routes.set(locateRoutes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　CompositeRouteLocator，其内部维护了routeLocators的集合，并继承了RefreshableRouteLocator方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * RouteLocator that composes multiple RouteLocators.</span><br><span class="line"> *</span><br><span class="line"> * @author Johannes Edmeier</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CompositeRouteLocator implements RefreshableRouteLocator &#123;</span><br><span class="line">private final Collection&lt;? extends RouteLocator&gt; routeLocators;</span><br><span class="line">private ArrayList&lt;RouteLocator&gt; rl;</span><br><span class="line"></span><br><span class="line">public CompositeRouteLocator(Collection&lt;? extends RouteLocator&gt; routeLocators) &#123;</span><br><span class="line">Assert.notNull(routeLocators, &quot;&apos;routeLocators&apos; must not be null&quot;);</span><br><span class="line">rl = new ArrayList&lt;&gt;(routeLocators);</span><br><span class="line">AnnotationAwareOrderComparator.sort(rl);</span><br><span class="line">this.routeLocators = rl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Collection&lt;String&gt; getIgnoredPaths() &#123;</span><br><span class="line">List&lt;String&gt; ignoredPaths = new ArrayList&lt;&gt;();</span><br><span class="line">for (RouteLocator locator : routeLocators) &#123;</span><br><span class="line">ignoredPaths.addAll(locator.getIgnoredPaths());</span><br><span class="line">&#125;</span><br><span class="line">return ignoredPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public List&lt;Route&gt; getRoutes() &#123;</span><br><span class="line">List&lt;Route&gt; route = new ArrayList&lt;&gt;();</span><br><span class="line">for (RouteLocator locator : routeLocators) &#123;</span><br><span class="line">route.addAll(locator.getRoutes());</span><br><span class="line">&#125;</span><br><span class="line">return route;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Route getMatchingRoute(String path) &#123;</span><br><span class="line">for (RouteLocator locator : routeLocators) &#123;</span><br><span class="line">Route route = locator.getMatchingRoute(path);</span><br><span class="line">if (route != null) &#123;</span><br><span class="line">return route;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void refresh() &#123;</span><br><span class="line">for (RouteLocator locator : routeLocators) &#123;</span><br><span class="line">if (locator instanceof RefreshableRouteLocator) &#123;</span><br><span class="line">((RefreshableRouteLocator) locator).refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　routeLocators就是我们需要的入口了，如果我们可以自定义一个通过数据库来加载的路由Locator，并自己实现refresh方法，那么就初步实现了路由动态配置最重要的一步。<br>　　如何将自定义Locator添加至routeLocators集合中呢？我们来梳理一下Zuul初始化的过程，在jar中我们能够找到有两个分账关键的配置类，分别是ZuulServerAutoConfiguration与ZuulProxyAutoConfiguration。<br>　　ZuulServerAutoConfiguration，里面初始化了CompositeRouteLocator、SimpleRouteLocator、ZuulController、各种关键默认的Filter、ZuulRefreshListener等，是我们要实现目的的关键入口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　 @Bean</span><br><span class="line">@Primary</span><br><span class="line">public CompositeRouteLocator primaryRouteLocator(</span><br><span class="line">Collection&lt;RouteLocator&gt; routeLocators) &#123;</span><br><span class="line">return new CompositeRouteLocator(routeLocators);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是CompositeRouteLocator初始化入口，由此可见我们完全可以将自定义的Locator加载进去。</p><h3 id="自定义路由定位器与路由刷新策略"><a href="#自定义路由定位器与路由刷新策略" class="headerlink" title="自定义路由定位器与路由刷新策略"></a>自定义路由定位器与路由刷新策略</h3><p>　　根据上面的方法，我们便可以将自定义的locator添加进CompositeRouteLocator中的locators集合。<br>　　定义一个MyDynamicRouteLocator，实现RefreshableRouteLocator，Ordered接口，其核心功能有两点，其一是将数据库中配置的路由信息加载，作为路由定位方法判定的基础，其二是实现刷新方法，使之能够识别数据库中变化的配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyDynamicRouteLocator implements RefreshableRouteLocator, Ordered &#123;</span><br></pre></td></tr></table></figure><p>然后，在项目启动时初始化MyDynamicRouteLocator</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DynamicRouteConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public MyDynamicRouteLocator dynamicRouteLocator() &#123;</span><br><span class="line">       ... </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由动态配置的优化"><a href="#路由动态配置的优化" class="headerlink" title="路由动态配置的优化"></a>路由动态配置的优化</h3><p>　　Zuul默认会维持心跳每隔30秒调用一次refresh方法来刷新路由信息，如果路由配置发生变更时，我们希望它可以实时生效，如何做呢？<br>　　前面提到ZuulServerAutoConfiguration内部初始化了一个ZuulRefreshListener，它实现了Spring的ApplicationListener接口，当它监听到一些指定的Event时，便最终会调用refresh方法来刷新路由配置信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private static class ZuulRefreshListener</span><br><span class="line">implements ApplicationListener&lt;ApplicationEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private ZuulHandlerMapping zuulHandlerMapping;</span><br><span class="line"></span><br><span class="line">private HeartbeatMonitor heartbeatMonitor = new HeartbeatMonitor();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">if (event instanceof ContextRefreshedEvent</span><br><span class="line">|| event instanceof RefreshScopeRefreshedEvent</span><br><span class="line">|| event instanceof RoutesRefreshedEvent</span><br><span class="line">|| event instanceof InstanceRegisteredEvent) &#123;</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line">else if (event instanceof ParentHeartbeatEvent) &#123;</span><br><span class="line">ParentHeartbeatEvent e = (ParentHeartbeatEvent) event;</span><br><span class="line">resetIfNeeded(e.getValue());</span><br><span class="line">&#125;</span><br><span class="line">else if (event instanceof HeartbeatEvent) &#123;</span><br><span class="line">HeartbeatEvent e = (HeartbeatEvent) event;</span><br><span class="line">resetIfNeeded(e.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void resetIfNeeded(Object value) &#123;</span><br><span class="line">if (this.heartbeatMonitor.update(value)) &#123;</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void reset() &#123;</span><br><span class="line">this.zuulHandlerMapping.setDirty(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　因此，我们可以通过广播-订阅的方式，建立一个Zuul的管理后台，当我们认为将路由配置信息变更时，发送一个广播，在Zuul集群的服务中实时监听该消息，当监听到刷新请求后，通过ApplicationEventPublisher发布RoutesRefreshedEvent，Zuul的事件监听器会自动为我们处理后续流程，从而实现了配置修改的实时刷新。<br>　　<br><img src="/images/15397653100461/15398449182455.jpg" alt=""></p><p>核心方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 取得订阅的消息后的处理</span><br><span class="line"> *</span><br><span class="line"> * 说明：当接收到路由规则刷新通知时, 发布路由刷新事件</span><br><span class="line"> * @param channel</span><br><span class="line"> * @param message</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onMessage(String channel, String message) &#123;</span><br><span class="line">    // step. 发布路由刷新事件</span><br><span class="line">    this.publisher.publishEvent(new RoutesRefreshedEvent(compositeRouteLocator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Zuul与非Spring-Boot项目集成"><a href="#Zuul与非Spring-Boot项目集成" class="headerlink" title="Zuul与非Spring Boot项目集成"></a>Zuul与非Spring Boot项目集成</h2><p>　　前面介绍过，Zuul的动态路由与负载均衡离不开Spring Cloud的Discovery Client（例如Eureka）与Ribbon，对于Spring Boot项目来说，其接入成本即引入一个jar包，添加几行配置与注解即可与Zuul集成。<br>　　对于非Spring Boot项目，我们需要自己封装一个类似的spring-cloud-starter-netflix-eureka-client组件。</p><h3 id="自定义非Spring-Boot项目spring-cloud-starter-netflix-eureka-client组件"><a href="#自定义非Spring-Boot项目spring-cloud-starter-netflix-eureka-client组件" class="headerlink" title="自定义非Spring Boot项目spring-cloud-starter-netflix-eureka-client组件"></a>自定义非Spring Boot项目spring-cloud-starter-netflix-eureka-client组件</h3><p>　　参考官方starter，该组件内部的核心是eureka-client.jar，核心逻辑很简单，即项目启动时将项目的地址、Host等信息注册至Eureka中，并开启Eureka的心跳机制，以便监听服务状态实时更新注册中心。</p><h4 id="首先引入eureka-client"><a href="#首先引入eureka-client" class="headerlink" title="首先引入eureka-client"></a>首先引入eureka-client</h4><p>引入版本需与spring-cloud-starter-netflix-eureka-client所用一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Eureka --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.eureka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;eureka.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>　　这里需要注意一点，由于旧项目所用servlet-api版本不同，因此需要注意组件的依赖关系。</p><h4 id="定义Listener"><a href="#定义Listener" class="headerlink" title="定义Listener"></a>定义Listener</h4><p>Listener必须具有以下功能：</p><ul><li>项目启动时服务信息注册到Eureka，并提供心跳监测　　</li><li>项目销毁时注销Eureka</li><li>维持心跳监测</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用途：Eureka服务注册</span><br><span class="line"> * 说明：</span><br><span class="line"> *      1、项目启动时服务信息注册到Eureka, 并提供心跳监测</span><br><span class="line"> *      2、项目销毁时注销Eureka</span><br><span class="line"> *      3、Eureka客户端默认配置的覆盖选项从Classpath下寻找eureka-client.properties中加载</span><br><span class="line"> *</span><br><span class="line"> * @author Wang Ran &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class EurekaDiscoveryListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">    private static ApplicationInfoManager applicationInfoManager;</span><br><span class="line">    private static EurekaClient eurekaClient;</span><br><span class="line">    private static EurekaInstanceConfig instanceConfig;</span><br><span class="line">    private static EurekaClientConfig clientConfig = new DefaultEurekaClientConfig();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务启动时调用, 注册Eureka</span><br><span class="line">     * @param sce</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        // step. 初始化Eureka Client</span><br><span class="line">        try &#123;</span><br><span class="line">            final String ipAddress = EurekaClientUtils.getLocalIpAddress();</span><br><span class="line">            instanceConfig = new MyDataCenterInstanceConfig() &#123;</span><br><span class="line">                /**</span><br><span class="line">                 * 强制将注册到Eureka的hostName从主机名换成IP地址加端口号的形式</span><br><span class="line">                 * @param refresh</span><br><span class="line">                 * @return</span><br><span class="line">                 */</span><br><span class="line">                @Override</span><br><span class="line">                public String getHostName(boolean refresh) &#123;</span><br><span class="line">                    return ipAddress;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * 强制将Eureka上显示的实例名称初始化为ip:appname:port的形式</span><br><span class="line">                 * @return</span><br><span class="line">                 */</span><br><span class="line">                @Override</span><br><span class="line">                public String getInstanceId() &#123;</span><br><span class="line">                    return ipAddress.concat(&quot;:&quot;).concat(this.getAppname())</span><br><span class="line">                            .concat(&quot;:&quot;).concat(String.valueOf(this.getNonSecurePort()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; catch (SocketException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Eureka Register init process occurred SocketException&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化Eureka ApplicationInfoManager</span><br><span class="line">        initializeApplicationInfoManager(instanceConfig);</span><br><span class="line">        // 初始化Eureka客户端并向Eureka注册</span><br><span class="line">        initializeEurekaClient(applicationInfoManager, clientConfig);</span><br><span class="line">        // 注册成功后向Eureka通知注册状态</span><br><span class="line">        applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 服务销毁时调用, 注销Eureka</span><br><span class="line">     * @param servletContextEvent</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void contextDestroyed(ServletContextEvent servletContextEvent) &#123;</span><br><span class="line">        eurekaClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化Eureka ApplicationInfoManager</span><br><span class="line">     * @param instanceConfig</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static synchronized ApplicationInfoManager initializeApplicationInfoManager(</span><br><span class="line">            EurekaInstanceConfig instanceConfig) &#123;</span><br><span class="line">        if (applicationInfoManager == null) &#123;</span><br><span class="line">            InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();</span><br><span class="line">            applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return applicationInfoManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化Eureka客户端</span><br><span class="line">     * @param applicationInfoManager</span><br><span class="line">     * @param clientConfig</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static synchronized EurekaClient initializeEurekaClient(</span><br><span class="line">            ApplicationInfoManager applicationInfoManager, EurekaClientConfig clientConfig) &#123;</span><br><span class="line">        if (eurekaClient == null) &#123;</span><br><span class="line">            eurekaClient = new DiscoveryClient(applicationInfoManager, clientConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        return eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非Spring-Boot项目客户端接入Eureka"><a href="#非Spring-Boot项目客户端接入Eureka" class="headerlink" title="非Spring Boot项目客户端接入Eureka"></a>非Spring Boot项目客户端接入Eureka</h3><h4 id="引入自定义Client"><a href="#引入自定义Client" class="headerlink" title="引入自定义Client"></a>引入自定义Client</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.xxx&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;my-spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;xxx.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="在Classpath添加文件：eureka-client-properties"><a href="#在Classpath添加文件：eureka-client-properties" class="headerlink" title="在Classpath添加文件：eureka-client.properties"></a>在Classpath添加文件：eureka-client.properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">### Eureka Client configuration</span><br><span class="line"></span><br><span class="line"># configuration related to reaching the eureka servers</span><br><span class="line"># 例如：http://eureka-node1:port/eureka/,http://eureka-node2:port/eureka/</span><br><span class="line">eureka.serviceUrl.default=$&#123;EUREKA_URI&#125;</span><br><span class="line"># 输入客户端服务集群的id, 名称需为英文, 例如: xxx-server</span><br><span class="line">eureka.name=$&#123;EUREKA-CLIENT-ID&#125;</span><br><span class="line"># 输入客户端服务端口, 例如8080</span><br><span class="line">eureka.port=$&#123;EUREKA-CLIENT-PORT&#125;</span><br><span class="line"># 向服务发现注册真实ip</span><br><span class="line">eureka.instance.prefer-ip-address=true</span><br><span class="line"># 心跳时间，即服务续约间隔时间（缺省为30s）</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds=5</span><br><span class="line"># 发呆时间，即服务续约到期时间（缺省为90s）</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds=20</span><br><span class="line"># 客户识别此服务的虚拟主机名</span><br><span class="line">eureka.vipAddress=$&#123;eureka.name&#125;</span><br><span class="line">eureka.vitualVipAddress=$&#123;eureka.name&#125;</span><br><span class="line">## configuration related to reaching the eureka servers</span><br><span class="line">eureka.preferSameZone=true</span><br><span class="line"># 是否要使用基于DNS的查找来确定其他eureka服务器</span><br><span class="line">eureka.shouldUseDns=false</span><br><span class="line"># 是否注册自身到eureka</span><br><span class="line">eureka.registration.enabled=true</span><br><span class="line">eureka.decoderName=JacksonJson</span><br></pre></td></tr></table></figure><h4 id="web-xml文件引入Eureka监听器"><a href="#web-xml文件引入Eureka监听器" class="headerlink" title="web.xml文件引入Eureka监听器"></a>web.xml文件引入Eureka监听器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;description&gt;Eureka Listener&lt;/description&gt;</span><br><span class="line">    &lt;listener-class&gt;com.xxx.listener.EurekaDiscoveryListener&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="分流上线-amp-验证"><a href="#分流上线-amp-验证" class="headerlink" title="分流上线 &amp; 验证"></a>分流上线 &amp; 验证</h2><p>　　前文所述，我们现有集群架构接入Zuul面临了一些上线问题：</p><ul><li>App端每次更新都要重新发版，时效性差</li><li>App端接入Zuul后若出现问题，无法及时回滚</li><li>旧版本App无法修改接入Zuul</li><li>测试与线上环境不一致，上线存在未知的风险</li><li>我们的业务模式，无法在线上环境进行全流程测试</li></ul><p>　　为了解决上述问题，我们必须做到在前端不进行任何修改的情况下，以一种分流且可验证的形式接入Zuul中。</p><h3 id="分流方案"><a href="#分流方案" class="headerlink" title="分流方案"></a>分流方案</h3><p>　　　　<img src="/images/15397653100461/Spring%20Cloud%20Zuul%2002%20-1-.jpg" alt="Spring Cloud Zuul 02 -1-"><br>　　若想做到前端在前期不做任何修改，意味着Zuul当前必须与前端已有的Nginx域名对接。<br>　　我们假设Zuul的域名为：my-zuul.com，旧服务1的域名为old-service-01.com，映射的机器为10.10.10.1，10.10.10.2。<br>　　对于分流方案，我们可以直接以Nginx的轮询策略为基准，将my-zuul.com作为类似10.10.10.1的一个节点，通过权重的形式将一部分访问old-service-01.com的流量分发到10.10.10.1，一部分流量分发到my-zuul.com。<br>　　但是这里存在一个问题，前端需要将old-service-01.com域名替换为my-zuul.com/service-01，而Nginx的upstream在映射到zuul.com时无法为域名添加/service-01，因此需要引入old-service-01-neiwang.com域名来解决这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　upstream old-service-01.com &#123;</span><br><span class="line">　   server 10.10.10.1:8080 fail_timeout=10s max_fails=3 weight 1;</span><br><span class="line">　   ...</span><br><span class="line">　   server old-service-01-neiwang.com weight 1;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure><p>　　然后，在Nginx中针对old-service-01-neiwang.com域名进行redirect，使之转到my-zuul.com/service-01，最终的架构详见下图。</p><p>　　<img src="/images/15397653100461/Spring%20Cloud%20Zuul%2003.jpg" alt="Spring Cloud Zuul 03"></p><p>　　</p><h3 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h3><p>　　通过Nginx我们实现了分流的上线策略，那么便可通过新增Post类型的自定义过滤器，拦截服务之间的请求与响应关键信息，进而通过streaming实时分析日志记录，监测Zuul的访问情况与业务数据的指标范围，来确定上线是否存在异常情形，进而可以逐步提升Zuul在Nginx的分流权重，直至最终将老架构过渡到以Zuul为核心的最终方案。</p><p><img src="/images/15397653100461/15398532205321.jpg" alt=""><br><img src="/images/15397653100461/15398533229844.jpg" alt=""></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　本文主要与大家分享一下我们在使用Spring Cloud中关于Zuul的一些实践心得，鉴于作者水平有限，文章中不免会有理解不到位的地方。关于Zuul本身与其他Spring Cloud组件，以及其他微服务架构有非常多的地方值得深入探讨，若您对文章中某些问题存在疑问，或是发现某些内容存在错误、有更好的解决方案、意见以及建议等，欢迎留言，非常希望能与各路大神广泛交流。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html" target="_blank" rel="noopener">Spring Cloud官方文档</a></p><p><a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文主要针对Zuul在实际业务场景中的一些实践心得进行总结，重点围绕Zuul本身关于动态配置缺陷问题、老项目接入及老环境上线问题等方面进行讨论。关于Zuul的一些基本用法，可直接参考&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud官方文档
&lt;/a&gt;与&lt;a href=&quot;https://github.com/Netflix/zuul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zuul Github&lt;/a&gt;。&lt;br&gt;　　我们使用的Zuul基于Spring官方目前最新版本Spring Cloud Finchley.SR1。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="https://wangran.me/categories/Spring-Cloud/"/>
    
    
      <category term="Zuul" scheme="https://wangran.me/tags/Zuul/"/>
    
  </entry>
  
  <entry>
    <title>基于Github搭建个人博客</title>
    <link href="https://wangran.me/2016/10/20/github_pages_init/"/>
    <id>https://wangran.me/2016/10/20/github_pages_init/</id>
    <published>2016-10-19T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Github搭建个人博客"><a href="#基于Github搭建个人博客" class="headerlink" title="基于Github搭建个人博客"></a>基于Github搭建个人博客</h1><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><h3 id="什么是github-pages？"><a href="#什么是github-pages？" class="headerlink" title="什么是github pages？"></a>什么是github pages？</h3><p>GitHub Pages is a static site hosting service.</p><p>GitHub Pages is designed to host your personal, organization, or project pages directly from a GitHub repository. To learn more about the different types of GitHub Pages sites, see “<a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">User, organization, and project pages</a>.”</p><p>You can create and publish GitHub Pages online using the <a href="https://help.github.com/articles/creating-pages-with-the-automatic-generator" target="_blank" rel="noopener">Automatic Page Generator</a>. If you prefer to work locally, you can use <a href="http://desktop.github.com" target="_blank" rel="noopener">GitHub Desktop</a> or the <a href="https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line" target="_blank" rel="noopener">command line</a>.</p><p> 由用户编写的、免费的、托管在github上的静态网页</p><hr><a id="more"></a><h3 id="如何搭建Github-Pages"><a href="#如何搭建Github-Pages" class="headerlink" title="如何搭建Github Pages"></a>如何搭建Github Pages</h3><p>官方教程</p><p> <a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></p><p><a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">https://help.github.com/articles/user-organization-and-project-pages/</a></p><p>搭建github博客基本分为如下几步：</p><ul><li>第一步，create a repository</li><li>第二步， clone the repository</li><li>第三步，create your website pages</li><li>第四步，commit and push your files</li></ul><p>github pages为我们搭建的个人博客地址是有规则的：<br>例如，我的github地址为<a href="https://github.com/wr4javaee" target="_blank" rel="noopener">https://github.com/wr4javaee</a><br>那么，我的博客主页地址为<a href="https://wr4javaee.github.io" target="_blank" rel="noopener">https://wr4javaee.github.io</a></p><p>若我的项目名称叫blog，那么对应的pages地址就是<a href="https://wr4javaee.github.io/blog" target="_blank" rel="noopener">https://wr4javaee.github.io/blog</a></p><ul><li>注册github账号</li></ul><p><a href="https://github.com/join" target="_blank" rel="noopener">https://github.com/join</a></p><p><a href="mailto:onepieceworld@qq.com" target="_blank" rel="noopener">onepieceworld@qq.com</a>&amp;3377128016，<a href="mailto:protosssoul@qq.com" target="_blank" rel="noopener">protosssoul@qq.com</a>&amp;2027194199</p><p><img src="/images/blog_create/create_repository.png" alt=""></p><p>github为我们准备了两种搭建博客方式，一种是github提供模板，我们只需写md文档即可。另一种是从头搭建。</p><p>我们先介绍第一种方式。</p><h4 id="方法一，利用github-pages模板搭建博客"><a href="#方法一，利用github-pages模板搭建博客" class="headerlink" title="方法一，利用github pages模板搭建博客"></a>方法一，利用github pages模板搭建博客</h4><p>进入项目-&gt;settings-&gt;github pages-&gt;launch</p><p><img src="/images/blog_create/settings_lunch.png" alt=""></p><p>点击launch后，进入</p><p><img src="/images/blog_create/lunch_page1.png" alt=""></p><p>填写好项目名称、项目描述后，进入下一步，选择项目模板</p><p><img src="/images/blog_create/settings_theme.png" alt=""></p><p>选择好模板后，点击 publish page即可提交。</p><p>稍等片刻后，github即可为我们搭建好项目对应的网站。</p><p>通过访问<a href="https://onepieceworld.github.io/test/" target="_blank" rel="noopener">https://onepieceworld.github.io/test/</a></p><h4 id="方法二，从头搭建博客"><a href="#方法二，从头搭建博客" class="headerlink" title="方法二，从头搭建博客"></a>方法二，从头搭建博客</h4><p>若我们查看github模板为我们创建的博客，会发现github为我们自动创建了一个分支gh-pages作为默认分支，博客的文件都提交在这个特定的分支中。</p><p><img src="/images/blog_create/git_branch.png" alt=""></p><p>那么，若我们从头搭建博客，就得模仿这一步骤。github规定，只有该分支中的页面，才会生成静态网页文件。</p><p>我们新创建一个reponsitory，名为test1</p><p><a href="https://github.com/onepieceworld/test1.git" target="_blank" rel="noopener">https://github.com/onepieceworld/test1.git</a></p><p>接下来，我们创建一个全新的gh-pages分支，并将其作为默认分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:~/github/test1$ git checkout --orphan gh-pages</span><br></pre></td></tr></table></figure><p>为新的空白分支创建默认页面并提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:~/github/test1$ git checkout --orphan gh-pages</span><br><span class="line">Switched to a new branch &apos;gh-pages&apos;</span><br><span class="line">yumao@ubuntu:~/github/test1$ git branch </span><br><span class="line">yumao@ubuntu:~/github/test1$ echo &quot;Hello World!&quot; &gt; index.html</span><br><span class="line">yumao@ubuntu:~/github/test1$ git add index.html </span><br><span class="line">yumao@ubuntu:~/github/test1$ git commit -a -m &quot;commit index pages&quot;</span><br><span class="line">[gh-pages (root-commit) 0fab7c5] commit index pages</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 index.html</span><br><span class="line">yumao@ubuntu:~/github/test1$ git push origin gh-pages</span><br></pre></td></tr></table></figure><p>提交成功后，访问<a href="https://onepieceworld.github.io/test1/，" target="_blank" rel="noopener">https://onepieceworld.github.io/test1/，</a></p><p>可以看到，github已经自动为我们将静态文件部署。</p><hr><h2 id="利用Jekyll搭建个人博客"><a href="#利用Jekyll搭建个人博客" class="headerlink" title="利用Jekyll搭建个人博客"></a>利用Jekyll搭建个人博客</h2><p><a href="http://jekyll.com.cn" target="_blank" rel="noopener">Jekyll官方网站</a><br><a href="https://github.com/jekyll/jekyll" target="_blank" rel="noopener">Jekyll github</a></p><h3 id="什么是Jekyll？"><a href="#什么是Jekyll？" class="headerlink" title="什么是Jekyll？"></a>什么是Jekyll？</h3><p>Jekyll is a simple, blog-aware, static site generator perfect for<br>personal, project, or organization sites. Think of it like a file-based<br>CMS, without all the complexity. Jekyll takes your content, renders<br>Markdown and Liquid templates, and spits out a complete, static website<br>ready to be served by Apache, Nginx or another web server. Jekyll is the<br> engine behind <a href="https://pages.github.com" target="_blank" rel="noopener">GitHub Pages</a>, which you can use to host sites right from your GitHub repositories.</p><p>一个可以将纯文本转化为静态网站文件的生成器。</p><p>基于Jekyll，我们可以只关注编写纯文本，如markdown，而无需将精力放在HTML本身。</p><h3 id="Jekyll的简易用法"><a href="#Jekyll的简易用法" class="headerlink" title="Jekyll的简易用法"></a>Jekyll的简易用法</h3><blockquote><p><a href="http://jekyll.bootcss.com/" target="_blank" rel="noopener">Jekyll官方使用简介</a>，内容很详细<br><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">作者阮一峰关于Jekyll与Github Blog的入门教程</a>，推荐大家阅读</p></blockquote><p>首先，Jekyll依赖Ruby</p><p>安装Ruby环境过程中会遇到GWF，需要用到淘宝提供的RubyGems镜像服务，它与官方服务同步频率为15分钟。</p><p>Ruby环境搭建好后，我们通过以下命令安装Jekyll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~ $ gem install jekyll</span><br></pre></td></tr></table></figure><p>接下来，利用jekyll命令jekyll new my-awesome-site自动创建jekyll项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:~/github$ jekyll new jekyll_test</span><br><span class="line">New jekyll site installed in /home/yumao/github/jekyll_test. </span><br><span class="line">Running bundle install in /home/yumao/github/jekyll_test... </span><br><span class="line">Fetching gem metadata from https://rubygems.org/................</span><br><span class="line">Fetching version metadata from https://rubygems.org/...</span><br><span class="line">Fetching dependency metadata from https://rubygems.org/..</span><br><span class="line">Resolving dependencies...</span><br><span class="line">Using addressable 2.4.0</span><br><span class="line">Using colorator 1.1.0</span><br><span class="line">Using ffi 1.9.14</span><br><span class="line">Using forwardable-extended 2.6.0</span><br><span class="line">Using sass 3.4.22</span><br><span class="line">Using rb-fsevent 0.9.7</span><br><span class="line">Using kramdown 1.12.0</span><br><span class="line">Using liquid 3.0.6</span><br><span class="line">Using mercenary 0.3.6</span><br><span class="line">Using rouge 1.11.1</span><br><span class="line">Using safe_yaml 1.0.4</span><br><span class="line">Using minima 2.0.0</span><br><span class="line">Using bundler 1.13.5</span><br><span class="line">Using rb-inotify 0.9.7</span><br><span class="line">Using pathutil 0.14.0</span><br><span class="line">Using jekyll-sass-converter 1.4.0</span><br><span class="line">Using listen 3.0.8</span><br><span class="line">Using jekyll-watch 1.5.0</span><br><span class="line">Using jekyll 3.3.0</span><br><span class="line">Using jekyll-feed 0.8.0</span><br><span class="line">Bundle complete! 3 Gemfile dependencies, 20 gems now installed.</span><br><span class="line">Use `bundle show [gemname]` to see where a bundled gem is installed.</span><br><span class="line">yumao@ubuntu:~/github$</span><br></pre></td></tr></table></figure><p>进入项目目录下，执行Jekyll命令 jekyll serve，启动项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:~/github$ cd jekyll_test/</span><br><span class="line">yumao@ubuntu:~/github/jekyll_test$ jekyll serve</span><br><span class="line">WARN: Unresolved specs during Gem::Specification.reset:</span><br><span class="line">      rouge (~&gt; 1.7)</span><br><span class="line">      jekyll-watch (~&gt; 1.1)</span><br><span class="line">WARN: Clearing out unresolved specs.</span><br><span class="line">Please report a bug if this causes problems.</span><br><span class="line">Configuration file: /home/yumao/github/jekyll_test/_config.yml</span><br><span class="line">Configuration file: /home/yumao/github/jekyll_test/_config.yml</span><br><span class="line">            Source: /home/yumao/github/jekyll_test</span><br><span class="line">       Destination: /home/yumao/github/jekyll_test/_site</span><br><span class="line"> Incremental build: disabled. Enable with --incremental</span><br><span class="line">      Generating... </span><br><span class="line">                    done in 0.286 seconds.</span><br><span class="line"> Auto-regeneration: enabled for &apos;/home/yumao/github/jekyll_test&apos;</span><br><span class="line">Configuration file: /home/yumao/github/jekyll_test/_config.yml</span><br><span class="line">    Server address: http://127.0.0.1:4000/</span><br><span class="line">  Server running... press ctrl-c to stop.</span><br></pre></td></tr></table></figure><p><img src="/images/blog_create/jekyll_default_page.png" alt=""></p><p>至此，一个简易的jekyll项目就搭建好了，我们将它部署到github中，每次只要新增md文档，提交到github后，其会自动编译jekyll项目，自动解析成静态网页文件。</p><h3 id="Jekyll的目录结构"><a href="#Jekyll的目录结构" class="headerlink" title="Jekyll的目录结构"></a>Jekyll的目录结构</h3><p><img src="/images/blog_create/jekyll_files.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── _drafts</span><br><span class="line">|   ├── begin-with-the-crazy-ideas.textile</span><br><span class="line">|   └── on-simplicity-in-technology.markdown</span><br><span class="line">├── _includes</span><br><span class="line">|   ├── footer.html</span><br><span class="line">|   └── header.html</span><br><span class="line">├── _layouts</span><br><span class="line">|   ├── default.html</span><br><span class="line">|   └── post.html</span><br><span class="line">├── _posts</span><br><span class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span><br><span class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span><br><span class="line">├── _data</span><br><span class="line">|   └── members.yml</span><br><span class="line">├── _site</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><table><thead><tr><th>文件 / 目录</th><th>描述</th></tr></thead><tbody><tr><td><code>_config.yml</code></td><td>保存<a href="http://jekyll.com.cn/docs/configuration/" target="_blank" rel="noopener">配置</a>数据。很多配置选项都会直接从命令行中进行设置，但是如果你把那些配置写在这儿，你就不用非要去记住那些命令了。</td></tr><tr><td><code>_drafts</code></td><td>drafts 是未发布的文章。这些文件的格式中都没有 <code>title.MARKUP</code> 数据。学习如何使用 <a href="http://jekyll.com.cn/docs/drafts/" target="_blank" rel="noopener">drafts</a>.</td></tr><tr><td><code>_includes</code></td><td>你可以加载这些包含部分到你的布局或者文章中以方便重用。可以用这个标签          <code>{nclude file.ext</code>          来把文件 <code>_includes/file.ext</code> 包含进来。</td></tr><tr><td><code>_layouts</code></td><td>layouts 是包裹在文章外部的模板。布局可以在 <a href="http://jekyll.com.cn/docs/frontmatter/" target="_blank" rel="noopener">YAML 头信息</a>中根据不同文章进行选择。          这将在下一个部分进行介绍。标签          <code>content</code>          可以将content插入页面中。</td></tr><tr><td><code>_posts</code></td><td>这里放的就是你的文章了。文件格式很重要，必须要符合:          <code>YEAR-MONTH-DAY-title.MARKUP</code>。          The <a href="http://jekyll.com.cn/docs/permalinks/" target="_blank" rel="noopener">permalinks</a> 可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。</td></tr><tr><td><code>_data</code></td><td>Well-formatted site data should be placed here. The jekyll engine will           autoload all yaml files (ends with <code>.yml</code> or <code>.yaml</code>)           in this directory. If there’s a file <code>members.yml</code> under the directory,           then you can access contents of the file through <code>site.data.members</code>.</td></tr><tr><td><code>_site</code></td><td>一旦 Jekyll 完成转换，就会将生成的页面放在这里（默认）。最好将这个目录放进你的 <code>.gitignore</code> 文件中。</td></tr><tr><td><code>index.html</code> and other HTML, Markdown, Textile files</td><td>如果这些文件中包含 <a href="http://jekyll.com.cn/docs/frontmatter/" target="_blank" rel="noopener">YAML 头信息</a> 部分，Jekyll 就会自动将它们进行转换。当然，其他的如 <code>.html</code>， <code>.markdown</code>，          <code>.md</code>，或者 <code>.textile</code> 等在你的站点根目录下或者不是以上提到的目录中的文件也会被转换。</td></tr><tr><td>Other Files/Folders</td><td>其他一些未被提及的目录和文件如          <code>css</code> 还有 <code>images</code> 文件夹，          <code>favicon.ico</code> 等文件都将被完全拷贝到生成的 site 中。 这里有一些<a href="http://jekyll.com.cn/docs/sites/" target="_blank" rel="noopener">使用 Jekyll 的站点</a>，如果你感兴趣就来看看吧。</td></tr></tbody></table><h4 id="config-yml配置文件"><a href="#config-yml配置文件" class="headerlink" title="_config.yml配置文件"></a>_config.yml配置文件</h4><p><a href="http://jekyll.com.cn/docs/configuration/" target="_blank" rel="noopener">官方配置文件说明</a></p><h3 id="使用Jekyll的开源模板"><a href="#使用Jekyll的开源模板" class="headerlink" title="使用Jekyll的开源模板"></a>使用Jekyll的开源模板</h3><p>网络上免费的Jekyll主题非常多，推荐2个主题网站</p><blockquote><p><a href="http://jekyllthemes.org/" target="_blank" rel="noopener">Jekyll主题网站一</a></p><p><a href="http://jekyllthemes.io/" target="_blank" rel="noopener">Jekyll主题网站二</a></p></blockquote><p>这里为大家推荐一个我喜欢的主题来源</p><blockquote><p><a href="http://gaohaoyang.github.io" target="_blank" rel="noopener">Gaohaoyang</a></p></blockquote><p>github地址</p><p><a href="https://github.com/Gaohaoyang/gaohaoyang.github.io.git" target="_blank" rel="noopener">https://github.com/Gaohaoyang/gaohaoyang.github.io.git</a></p><h3 id="Jekyll的优缺点"><a href="#Jekyll的优缺点" class="headerlink" title="Jekyll的优缺点"></a>Jekyll的优缺点</h3><p>Jekyll是比较流行的博客系统，其主题、插件数量上比较丰富，且上手简单。<br>缺点为文章量多的时候，生成速度慢。</p><hr><h2 id="利用Hexo搭建个人博客"><a href="#利用Hexo搭建个人博客" class="headerlink" title="利用Hexo搭建个人博客"></a>利用Hexo搭建个人博客</h2><h3 id="Hexo与Jekyll的区别"><a href="#Hexo与Jekyll的区别" class="headerlink" title="Hexo与Jekyll的区别"></a>Hexo与Jekyll的区别</h3><p>Hexo是基于Node.js编写的静态博客系统，使用Jekyl我们可以将原生的markdown文档上传到github，由github自动解析成静态html文件。但hexo为本地将markdown文档解析后，将生成的静态html文件直接上传到github中。</p><p>由于hexo基于nodejs，因此其生成html速度较Jekyll快，相对更灵活。主题数量然有Jade/Stylus/Less等各种方言支持。</p><table><thead><tr><th></th><th>语言</th><th>活跃度</th><th>开箱即用</th><th>主题数量</th><th>主题系统</th><th>生成速度</th><th>博客适应性</th><th>非博客适应性</th></tr></thead><tbody><tr><td>Jekyll</td><td>Ruby</td><td>S</td><td>B</td><td>A</td><td>A</td><td>C</td><td>A</td><td>C</td></tr><tr><td>Hexo</td><td>NodeJS</td><td>B</td><td>A</td><td>A</td><td>B</td><td>A</td><td>A</td><td>B</td></tr></tbody></table><h3 id="Hexo官方文档"><a href="#Hexo官方文档" class="headerlink" title="Hexo官方文档"></a>Hexo官方文档</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo基于Node.js，因此首先应安装Node.js环境。</p><p>cURL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure></p><p>安装完成后，重启终端执行下列命令完成安装Node.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure></p><p>若环境准备就绪，使用以下命令安装Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="使用Hexo建立网站"><a href="#使用Hexo建立网站" class="headerlink" title="使用Hexo建立网站"></a>使用Hexo建立网站</h3><p>使用以下命令初始化网站</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>建站后的文件目录如下：</p><p><img src="/images/blog_create/hexo_files.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><ul><li>scaffolds模板文件夹</li></ul><p>建站的模板，hexo依赖于此模板来生成静态文件。</p><ul><li>_config.yml配置文件</li></ul><p><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">hexo官方配置文件说明</a></p><p>以下为hexo的默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line"># 网站标题</span><br><span class="line">title: Hexo </span><br><span class="line"># 网站副标题</span><br><span class="line">subtitle: </span><br><span class="line"># 网站描述</span><br><span class="line">description: </span><br><span class="line">author: John Doe</span><br><span class="line"># 网站使用的语言</span><br><span class="line">language: </span><br><span class="line"># 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</span><br><span class="line">timezone: </span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line"># 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 #http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="line">url: http://yoursite.com</span><br><span class="line"># 网站根目录</span><br><span class="line">root: /</span><br><span class="line"># 文章的 永久链接 格式 :year/:month/:day/:title/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line"># 永久链接中各部分的默认值 </span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line"># 资源文件夹，这个文件夹用来存放内容。</span><br><span class="line">source_dir: source</span><br><span class="line"># 公共文件夹，这个文件夹用于存放生成的站点文件</span><br><span class="line">public_dir: public</span><br><span class="line"># 标签文件夹</span><br><span class="line">tag_dir: tags</span><br><span class="line"># 归档文件夹</span><br><span class="line">archive_dir: archives</span><br><span class="line"># 分类文件夹</span><br><span class="line">category_dir: categories</span><br><span class="line"># Include code 文件夹</span><br><span class="line">code_dir: downloads/code</span><br><span class="line"># 国际化（i18n）文件夹</span><br><span class="line">i18n_dir: :lang</span><br><span class="line"># 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 </span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line"># 默认分类 uncategorized</span><br><span class="line">default_category: uncategorized</span><br><span class="line"># 分类别名 </span><br><span class="line">category_map:</span><br><span class="line"># 标签别名 </span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line"># 日期格式 YYYY-MM-DD</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line"># 时间格式 H:mm:ss</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line"># 每页显示的文章量 (0 = 关闭分页功能) 10</span><br><span class="line">per_page: 10</span><br><span class="line"># 分页目录 page</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line"># 当前主题名称。值为false时禁用主题</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><ul><li>source资源文件夹</li></ul><p>用来存放用户资源，其中_post文件夹下的markdown文档，会被hexo自动解析成html，并放置到public文件夹中</p><p>其他以_开头的文件夹会被自动忽略</p><ul><li>themes主题文件夹</li></ul><p>hexo在解析时，会根据主题来生成静态页面。</p><h4 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>layout若不指定，默认从_config.yml文件中的default_layout代替</p><h4 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr></tbody></table><p>使用generate命令后，hexo的文件夹会自动生成静态文件，放置到配置文件中规定的public目录中</p><p><img src="/images/blog_create/hexo_files_after_generate_1.png" alt=""></p><p>public文件夹中的内容如下</p><p><img src="/images/blog_create/hexo_files_after_generate_2.png" alt=""></p><h4 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h4 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>部署后的界面如下<br><img src="/images/blog_create/hexo_server_page.png" alt=""></p><h4 id="清除缓存文件"><a href="#清除缓存文件" class="headerlink" title="清除缓存文件"></a>清除缓存文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p><img src="/images/blog_create/hexo_clean.png" alt=""></p><h4 id="其他hexo命令"><a href="#其他hexo命令" class="headerlink" title="其他hexo命令"></a>其他hexo命令</h4><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">其他hexo命令</a></p><h3 id="hexo部署到github中"><a href="#hexo部署到github中" class="headerlink" title="hexo部署到github中"></a>hexo部署到github中</h3><p>通过_config.yml文件建立关联，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/onepieceworld/hexo_test.git</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ npm install hexo-deployer-git --save</span><br><span class="line">~ $ hexo deploy</span><br></pre></td></tr></table></figure><p>至此，hexo已成功将解析后的html文件上传到github中</p><p><img src="/images/blog_create/hexo_github.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基于Github搭建个人博客&quot;&gt;&lt;a href=&quot;#基于Github搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;基于Github搭建个人博客&quot;&gt;&lt;/a&gt;基于Github搭建个人博客&lt;/h1&gt;&lt;h2 id=&quot;Github-Pages&quot;&gt;&lt;a href=&quot;#Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;Github Pages&quot;&gt;&lt;/a&gt;Github Pages&lt;/h2&gt;&lt;h3 id=&quot;什么是github-pages？&quot;&gt;&lt;a href=&quot;#什么是github-pages？&quot; class=&quot;headerlink&quot; title=&quot;什么是github pages？&quot;&gt;&lt;/a&gt;什么是github pages？&lt;/h3&gt;&lt;p&gt;GitHub Pages is a static site hosting service.&lt;/p&gt;
&lt;p&gt;GitHub Pages is designed to host your personal, organization, or project pages directly from a GitHub repository. To learn more about the different types of GitHub Pages sites, see “&lt;a href=&quot;https://help.github.com/articles/user-organization-and-project-pages/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;User, organization, and project pages&lt;/a&gt;.”&lt;/p&gt;
&lt;p&gt;You can create and publish GitHub Pages online using the &lt;a href=&quot;https://help.github.com/articles/creating-pages-with-the-automatic-generator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Automatic Page Generator&lt;/a&gt;. If you prefer to work locally, you can use &lt;a href=&quot;http://desktop.github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub Desktop&lt;/a&gt; or the &lt;a href=&quot;https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;command line&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt; 由用户编写的、免费的、托管在github上的静态网页&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Github" scheme="https://wangran.me/categories/Github/"/>
    
    
      <category term="Github" scheme="https://wangran.me/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper Curator的使用</title>
    <link href="https://wangran.me/2016/07/27/zookeeper_curator/"/>
    <id>https://wangran.me/2016/07/27/zookeeper_curator/</id>
    <published>2016-07-26T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Curator是ZooKeeper的开源客户端。<br>官网：<a href="http://curator.apache.org/" target="_blank" rel="noopener">http://curator.apache.org/</a><br>API文档：<a href="http://curator.apache.org/apidocs/index.html" target="_blank" rel="noopener">http://curator.apache.org/apidocs/index.html</a><br><a id="more"></a></p><p>在工程中需要引入curator依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="截止目前文章中使用的版本为3-2-0"><a href="#截止目前文章中使用的版本为3-2-0" class="headerlink" title="截止目前文章中使用的版本为3.2.0"></a>截止目前文章中使用的版本为3.2.0</h2><h2 id="创建Session"><a href="#创建Session" class="headerlink" title="创建Session"></a>创建Session</h2><h3 id="使用CuratorFrameworkFactory创建Session"><a href="#使用CuratorFrameworkFactory创建Session" class="headerlink" title="使用CuratorFrameworkFactory创建Session"></a>使用CuratorFrameworkFactory创建Session</h3><p>可以通过newClient方法建立ZooKeeper会话，但这里推荐使用其自带的Builder模式，下面是newClient的官方API，Builder模式的case见下文。</p><ul><li><h4 id="newClient"><a href="#newClient" class="headerlink" title="newClient"></a>newClient</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static CuratorFramework newClient(String connectString,</span><br><span class="line">                                         RetryPolicy retryPolicy)</span><br></pre></td></tr></table></figure><p>Create a new client with default session timeout and default connection timeout</p><ul><li><p>Parameters:</p><p><code>connectString</code> - list of servers to connect to</p><p><code>retryPolicy</code> - retry policy to use</p></li><li><p>Returns:</p><p>client</p></li></ul></li></ul><ul><li><h4 id="newClient-1"><a href="#newClient-1" class="headerlink" title="newClient"></a>newClient</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static CuratorFramework newClient(String connectString,</span><br><span class="line">                                         int sessionTimeoutMs,</span><br><span class="line">                                         int connectionTimeoutMs,</span><br><span class="line">                                         RetryPolicy retryPolicy)</span><br></pre></td></tr></table></figure><p>Create a new client</p><ul><li><p>Parameters:</p><p><code>connectString</code> - list of servers to connect to</p><p><code>sessionTimeoutMs</code> - session timeout</p><p><code>connectionTimeoutMs</code> - connection timeout</p><p><code>retryPolicy</code> - retry policy to use</p></li><li><p>Returns:</p><p>client</p><p>​</p></li></ul></li></ul><p>RetryPolicy是Curator提供的创建会话的策略接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstracts the policy to use when retrying connections</span><br><span class="line"> */</span><br><span class="line">public interface RetryPolicy</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Called when an operation has failed for some reason. This method should return</span><br><span class="line">     * true to make another attempt.</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * @param retryCount the number of times retried so far (0 the first time)</span><br><span class="line">     * @param elapsedTimeMs the elapsed time in ms since the operation was attempted</span><br><span class="line">     * @param sleeper use this to sleep - DO NOT call Thread.sleep</span><br><span class="line">     * @return true/false</span><br><span class="line">     */</span><br><span class="line">    public boolean      allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方提供的RetryPolicy的继承关系如下，我们也可通过继承RetryPolicy来实现自己的策略类。</p><p><img src="images/curator/retrypolicy_extends.png" alt="retrypolicy_extends"></p><p>这里，我们使用ExponentialBackoffRetry这个重试策略来建立ZooKeeperSession。</p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wangran.zookeeper.demo.curator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.RetryPolicy;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Curator创建SessionDemo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Ran</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorCreateSessionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">createSessionDemo1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用CuratorFrameworkFactory创建Session</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSessionDemo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String connectString = <span class="string">"192.168.128.75:2181"</span>;</span><br><span class="line"><span class="keyword">int</span> baseSleepTimeMs = <span class="number">1000</span>; <span class="comment">// 初始sleep时间</span></span><br><span class="line"><span class="keyword">int</span> maxRetries = <span class="number">100</span>; <span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="keyword">int</span> maxSleepMs = <span class="number">25000</span>; <span class="comment">// 最大sleep时间</span></span><br><span class="line"><span class="comment">// ExponentialBackoffRetry : Retry policy that retries a set number of </span></span><br><span class="line"><span class="comment">// times with increasing sleep time between retries</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(baseSleepTimeMs, maxRetries, maxSleepMs);</span><br><span class="line"><span class="keyword">int</span> sessionTimeoutMs = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> connectionTimeoutMs = <span class="number">10000</span>;</span><br><span class="line">CuratorFramework cff = CuratorFrameworkFactory.builder()</span><br><span class="line">.connectString(connectString)</span><br><span class="line">.retryPolicy(retryPolicy)</span><br><span class="line">.sessionTimeoutMs(sessionTimeoutMs)</span><br><span class="line">.connectionTimeoutMs(connectionTimeoutMs)</span><br><span class="line">.build();</span><br><span class="line">cff.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"ZooKeeper current state is "</span> + cff.getState());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我运行该代码后，控制台报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: org.apache.zookeeper.server.quorum.flexible.QuorumMaj.&lt;init&gt;(Ljava/util/Map;)V</span><br><span class="line">at org.apache.curator.framework.imps.EnsembleTracker.&lt;init&gt;(EnsembleTracker.java:57)</span><br><span class="line">at org.apache.curator.framework.imps.CuratorFrameworkImpl.&lt;init&gt;(CuratorFrameworkImpl.java:158)</span><br><span class="line">at org.apache.curator.framework.CuratorFrameworkFactory$Builder.build(CuratorFrameworkFactory.java:156)</span><br><span class="line">at me.wangran.zookeeper.demo.curator.CuratorCreateSessionDemo.createSessionDemo1(CuratorCreateSessionDemo.java:36)</span><br><span class="line">at me.wangran.zookeeper.demo.curator.CuratorCreateSessionDemo.main(CuratorCreateSessionDemo.java:15)</span><br></pre></td></tr></table></figure><p>报错的原因如下：</p><blockquote><p>Curator 2.x.x - compatible with both ZooKeeper 3.4.x and ZooKeeper 3.5.x<br>Curator 3.x.x - compatible only with ZooKeeper 3.5.x and includes support for new features such as dynamic reconfiguration, etc.</p></blockquote><p>在依赖中，我引入的curator与zookeeper版本不兼容导致</p><blockquote>  <properties><br>      &lt;zookeeper.version&gt;3.4.6&lt;/zookeeper.version&gt;<br>      &lt;curator.version&gt;3.2.0&lt;/curator.version&gt;<br>  </properties></blockquote><p>将zookeeper版本改为3.5.2-alpha后ZooKeeper会话创建成功，控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZooKeeper current state is STARTED</span><br></pre></td></tr></table></figure><p>这里特别说明一下，这个zookeeper版本指的是maven依赖的客户端版本，并不是zookeeper服务本身的版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Curator是ZooKeeper的开源客户端。&lt;br&gt;官网：&lt;a href=&quot;http://curator.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curator.apache.org/&lt;/a&gt;&lt;br&gt;API文档：&lt;a href=&quot;http://curator.apache.org/apidocs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://curator.apache.org/apidocs/index.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://wangran.me/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper Java API的使用</title>
    <link href="https://wangran.me/2016/07/26/zookeeper_java_api/"/>
    <id>https://wangran.me/2016/07/26/zookeeper_java_api/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Zookeeper官方API文档 <a href="http://zookeeper.apache.org/doc/r3.4.6/api/index.html" target="_blank" rel="noopener">http://zookeeper.apache.org/doc/r3.4.6/api/index.html</a></p><a id="more"></a><h2 id="通过API建立ZooKeeper-Session"><a href="#通过API建立ZooKeeper-Session" class="headerlink" title="通过API建立ZooKeeper Session"></a>通过API建立ZooKeeper Session</h2><p>ZooKeeper构造方法官方文档摘录如下</p><blockquote><table><thead><tr><th>Constructor and Description</th></tr></thead><tbody><tr><td><code>ZooKeeper(String connectString,         int sessionTimeout,         Watcher watcher)</code>To create a ZooKeeper client object, the application needs to pass a connection string containing a comma separated list of host:port pairs, each corresponding to a ZooKeeper server.</td></tr><tr><td><code>ZooKeeper(String connectString,         int sessionTimeout,         Watcher watcher,         boolean canBeReadOnly)</code>To create a ZooKeeper client object, the application needs to pass a connection string containing a comma separated list of host:port pairs, each corresponding to a ZooKeeper server.</td></tr><tr><td><code>ZooKeeper(String connectString,         int sessionTimeout,         Watcher watcher,         long sessionId,         byte[] sessionPasswd)</code>To create a ZooKeeper client object, the application needs to pass a connection string containing a comma separated list of host:port pairs, each corresponding to a ZooKeeper server.</td></tr><tr><td><code>ZooKeeper(String connectString,         int sessionTimeout,         Watcher watcher,         long sessionId,         byte[] sessionPasswd,         boolean canBeReadOnly)</code>To create a ZooKeeper client object, the application needs to pass a connection string containing a comma separated list of host:port pairs, each corresponding to a ZooKeeper server.</td></tr></tbody></table></blockquote><p>Demo github地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wangran.zookeeper.demo.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Zookeeper 创建Session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Ran</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperSessionDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">demo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建最基本的会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperSessionDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建指定read only模式的会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181/test_root"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperSessionDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line"><span class="keyword">boolean</span> canBeReadOnly = <span class="keyword">true</span>; <span class="comment">// 是否支持read only模式，默认为false，若一个机器和Zookeeper Cluster过半机器失去网络连接，则不处理所有读写请求。若未true，则该情况可提供读请求。</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher, canBeReadOnly);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恢复会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span>  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181/test_root"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperSessionDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line"><span class="keyword">long</span> sessionId = zookeeper.getSessionId(); <span class="comment">// 用于恢复会话</span></span><br><span class="line"><span class="keyword">byte</span>[] sessionPwd = zookeeper.getSessionPasswd(); <span class="comment">// 用于恢复会话</span></span><br><span class="line">countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher, sessionId, sessionPwd);</span><br><span class="line">System.out.println(<span class="string">"zookeeper reconnecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper reconnected, state is "</span> + zookeeper.getState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ZooKeeperWatcherDemo process, watchedEvent is "</span> + watchedEvent);</span><br><span class="line"><span class="keyword">if</span>(KeeperState.SyncConnected == watchedEvent.getState()) &#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="通过API创建节点"><a href="#通过API创建节点" class="headerlink" title="通过API创建节点"></a>通过API创建节点</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>创建节点API地址：<a href="http://zookeeper.apache.org/doc/r3.4.6/api/index.html" target="_blank" rel="noopener">http://zookeeper.apache.org/doc/r3.4.6/api/index.html</a></p><p>这里，我们主要用到两个方法，分别是</p><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>String</code></td><td><code>create(String path,      byte[] data,      List acl,      CreateMode createMode)</code>Create a node with the given path.</td></tr><tr><td><code>void</code></td><td><code>create(String path,      byte[] data,      List acl,      CreateMode createMode,      AsyncCallback.StringCallback cb,      Object ctx)</code>The asynchronous version of create.</td></tr></tbody></table><ul><li>path 指定创建的节点路径</li><li>data 节点的内容</li><li>acl 创建节点策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This Id represents anyone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Id ANYONE_ID_UNSAFE = <span class="keyword">new</span> Id(<span class="string">"world"</span>, <span class="string">"anyone"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This Id is only usable to set ACLs. It will get substituted with the</span></span><br><span class="line"><span class="comment"> * Id's the client authenticated with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Id AUTH_IDS = <span class="keyword">new</span> Id(<span class="string">"auth"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a completely open ACL .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ArrayList&lt;ACL&gt; OPEN_ACL_UNSAFE = <span class="keyword">new</span> ArrayList&lt;ACL&gt;(</span><br><span class="line">        Collections.singletonList(<span class="keyword">new</span> ACL(Perms.ALL, ANYONE_ID_UNSAFE)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This ACL gives the creators authentication id's all permissions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ArrayList&lt;ACL&gt; CREATOR_ALL_ACL = <span class="keyword">new</span> ArrayList&lt;ACL&gt;(</span><br><span class="line">        Collections.singletonList(<span class="keyword">new</span> ACL(Perms.ALL, AUTH_IDS)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This ACL gives the world the ability to read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ArrayList&lt;ACL&gt; READ_ACL_UNSAFE = <span class="keyword">new</span> ArrayList&lt;ACL&gt;(</span><br><span class="line">        Collections</span><br><span class="line">                .singletonList(<span class="keyword">new</span> ACL(Perms.READ, ANYONE_ID_UNSAFE)));</span><br></pre></td></tr></table></figure><ul><li>cb 异步回调函数，当节点创建后ZooKeeper客户端自动调用本方法。需要实现StringCallback接口，重写processResult方法</li><li>ctx 回调方法执行时使用的对象，通常放置上线文Context信息</li></ul><ul><li>CreateMode节点类型枚举如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The znode will not be automatically deleted upon client's disconnect</span></span><br><span class="line"><span class="comment"> * 持久节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PERSISTENT (<span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The znode will not be automatically deleted upon client's disconnect,</span></span><br><span class="line"><span class="comment">* and its name will be appended with a monotonically increasing number.</span></span><br><span class="line"><span class="comment">* 持久顺序节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PERSISTENT_SEQUENTIAL (<span class="number">2</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The znode will be deleted upon the client's disconnect.</span></span><br><span class="line"><span class="comment"> * 临时节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EPHEMERAL (<span class="number">1</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The znode will be deleted upon the client's disconnect, and its name</span></span><br><span class="line"><span class="comment"> * will be appended with a monotonically increasing number.</span></span><br><span class="line"><span class="comment"> * 临时顺序节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EPHEMERAL_SEQUENTIAL (<span class="number">3</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>),</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The znode will be a container node. Container</span></span><br><span class="line"><span class="comment"> * nodes are special purpose nodes useful for recipes such as leader, lock,</span></span><br><span class="line"><span class="comment"> * etc. When the last child of a container is deleted, the container becomes</span></span><br><span class="line"><span class="comment"> * a candidate to be deleted by the server at some point in the future.</span></span><br><span class="line"><span class="comment"> * Given this property, you should be prepared to get</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.apache.zookeeper.KeeperException.NoNodeException&#125;</span></span><br><span class="line"><span class="comment"> * when creating children inside of this container node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CONTAINER (<span class="number">4</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h3><ul><li>case 1 根节点下创建持久节点/node_pokemon</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wangran.zookeeper.demo.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeper创建节点Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Ran</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperCreateNodeDemo</span>  <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ZooKeeperCreateNodeDemo().demo1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建最基本的会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperCreateNodeDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line"></span><br><span class="line">String newNodePath = <span class="string">"/node_pokemon"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] newNodeData = <span class="string">"go"</span>.getBytes();</span><br><span class="line">CreateMode newNodeMode = CreateMode.PERSISTENT;</span><br><span class="line">zookeeper.create(newNodePath, newNodeData, Ids.OPEN_ACL_UNSAFE, newNodeMode);</span><br><span class="line">System.out.println(<span class="string">"zookeeper node created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ZooKeeperWatcherDemo process, watchedEvent is "</span> + watchedEvent);</span><br><span class="line"><span class="keyword">if</span>(KeeperState.SyncConnected == watchedEvent.getState()) &#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><blockquote><p>zookeeper connecting, state is CONNECTING<br>ZooKeeperWatcherDemo process, watchedEvent is WatchedEvent state:SyncConnected type:None path:null<br>zookeeper connected, state is CONNECTED<br>zookeeper node created</p></blockquote><ul><li>case2 创建节点后异步触发回调函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.wangran.zookeeper.demo.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.AsyncCallback.StringCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZooKeeper创建节点Demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Ran</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperCreateNodeDemo</span>  <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ZooKeeperCreateNodeDemo().demo2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建持久节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperCreateNodeDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line"></span><br><span class="line">String newNodePath = <span class="string">"/node_pokemon"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] newNodeData = <span class="string">"go"</span>.getBytes();</span><br><span class="line">CreateMode newNodeMode = CreateMode.PERSISTENT;</span><br><span class="line">zookeeper.create(newNodePath, newNodeData, Ids.OPEN_ACL_UNSAFE, newNodeMode);</span><br><span class="line">System.out.println(<span class="string">"zookeeper node created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建节点后异步回调业务函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String zookeeperAddress = <span class="string">"192.168.128.75:2181/node_pokemon"</span>; <span class="comment">// Zookeeper地址，多个Zookeeper地址可以英文逗号分隔，地址可指定节点</span></span><br><span class="line"><span class="keyword">int</span> sessionTimeout = <span class="number">10000</span>; <span class="comment">// session超时时间，单位毫秒</span></span><br><span class="line">Watcher watcher = <span class="keyword">new</span> ZooKeeperCreateNodeDemo(); <span class="comment">// 事件通知处理器， 创建会话时可为null</span></span><br><span class="line">ZooKeeper zookeeper = <span class="keyword">new</span> ZooKeeper(zookeeperAddress, sessionTimeout, watcher);</span><br><span class="line">System.out.println(<span class="string">"zookeeper connecting, state is "</span> + zookeeper.getState());</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"zookeeper connected, state is "</span> + zookeeper.getState());</span><br><span class="line"></span><br><span class="line">String newNodePath = <span class="string">"/node_kinosaki"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] newNodeData = <span class="string">"osen"</span>.getBytes();</span><br><span class="line">CreateMode newNodeMode = CreateMode.PERSISTENT_SEQUENTIAL;</span><br><span class="line">Object ctx = <span class="string">"ContextDemo"</span>;</span><br><span class="line">zookeeper.create(newNodePath, newNodeData, Ids.OPEN_ACL_UNSAFE, newNodeMode, <span class="keyword">new</span> StringCallbackDemo(), ctx);</span><br><span class="line">System.out.println(<span class="string">"zookeeper node created"</span>);</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Wang Ran</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringCallbackDemo</span> <span class="keyword">implements</span> <span class="title">AsyncCallback</span>.<span class="title">StringCallback</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(<span class="keyword">int</span> rc, String path, Object ctx, String name)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"StringCallbackDemo.processResult executed!, resultCode is "</span> + rc</span><br><span class="line">+ <span class="string">", path is"</span> + path <span class="comment">// 调用接口时传入的Path</span></span><br><span class="line">+ <span class="string">", context is "</span> + ctx.toString() <span class="comment">// 调用接口时传入的Context</span></span><br><span class="line">+ <span class="string">", node name is "</span> + name); <span class="comment">// 实际在服务器中创建的节点名称</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"ZooKeeperWatcherDemo process, watchedEvent is "</span> + watchedEvent);</span><br><span class="line"><span class="keyword">if</span>(KeeperState.SyncConnected == watchedEvent.getState()) &#123;</span><br><span class="line">countDownLatch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><blockquote><p>zookeeper connecting, state is CONNECTING<br>ZooKeeperWatcherDemo process, watchedEvent is WatchedEvent state:SyncConnected type:None path:null<br>zookeeper connected, state is CONNECTED<br>zookeeper node created<br>StringCallbackDemo.processResult executed!, resultCode is 0, path is/node_kinosaki, context is ContextDemo, node name is /node_kinosaki0000000005</p></blockquote><hr><h2 id="通过API读取节点"><a href="#通过API读取节点" class="headerlink" title="通过API读取节点"></a>通过API读取节点</h2><h3 id="API说明："><a href="#API说明：" class="headerlink" title="API说明："></a>API说明：</h3><ul><li><h3 id="getChildren查询指定节点的所有子节点"><a href="#getChildren查询指定节点的所有子节点" class="headerlink" title="getChildren查询指定节点的所有子节点"></a>getChildren查询指定节点的所有子节点</h3></li><li><h3 id="getData查询指定节点的数据内容"><a href="#getData查询指定节点的数据内容" class="headerlink" title="getData查询指定节点的数据内容"></a>getData查询指定节点的数据内容</h3></li></ul><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>getChildren  (String path, boolean watch)</code>Return the list of the children of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>getChildren  (String path, boolean watch, AsyncCallback.Children2Callback cb, Object ctx)</code>The asynchronous version of getChildren.</td></tr><tr><td><code>void</code></td><td><code>getChildren  (String path, boolean watch, AsyncCallback.ChildrenCallback cb, Object ctx)</code>The asynchronous version of getChildren.</td></tr><tr><td><code>List</code></td><td><code>getChildren  (String path, boolean watch, Stat stat)</code>For the given znode path return the stat and children list.</td></tr><tr><td><code>List</code></td><td><code>getChildren  (String path, Watcher watcher)</code>Return the list of the children of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>getChildren  (String path, Watcher watcher, AsyncCallback.Children2Callback cb, Object ctx)</code>The asynchronous version of getChildren.</td></tr><tr><td><code>void</code></td><td><code>getChildren  (String path, Watcher watcher, AsyncCallback.ChildrenCallback cb, Object ctx)</code>The asynchronous version of getChildren.</td></tr><tr><td><code>List</code></td><td><code>getChildren  (String path, Watcher watcher, Stat stat)</code>For the given znode path return the stat and children list.</td></tr></tbody></table><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>getData(String path,       boolean watch,       AsyncCallback.DataCallback cb,       Object ctx)</code>The asynchronous version of getData.</td></tr><tr><td><code>byte[]</code></td><td><code>getData(String path,       boolean watch,       Stat stat)</code>Return the data and the stat of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>getData(String path,       Watcher watcher,       AsyncCallback.DataCallback cb,       Object ctx)</code>The asynchronous version of getData.</td></tr><tr><td><code>byte[]</code></td><td><code>getData(String path,       Watcher watcher,       Stat stat)</code>Return the data and the stat of the node of the given path.</td></tr></tbody></table><ul><li><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3></li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>想要查询的节点路径。</td></tr><tr><td>watch</td><td>false为不需要注册watcher，true为使用默认watcher。</td></tr><tr><td>watcher</td><td>可为null。指定watcher用于订阅子节点列表变化通知。当子节点被添加或删除时会向客户端发送通知（通知内容不包含节点列表，客户端需重新查询以获得节点列表信息）。</td></tr><tr><td>cb</td><td>异步回调函数</td></tr><tr><td>ctx</td><td>上下文对象</td></tr><tr><td>stat</td><td>指定数据节点的状态信息，包含cZxid（节点创建的事务id）、mZxid（节点最后一次更新的事务id）、dataLength（节点数据内容长度），传入变量的值会在方法执行过程中被服务器响应的值替换。</td></tr></tbody></table><h2 id="通过API更新节点"><a href="#通过API更新节点" class="headerlink" title="通过API更新节点"></a>通过API更新节点</h2><h3 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h3><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>Stat</code></td><td><code>setData  (String path,       byte[] data,       int version)</code>Set the data for the node of the given path if such a node exists and the given version matches the version of the node (if the given version is -1, it matches any node’s versions).说明：该方法为同步更新方法</td></tr><tr><td><code>void</code></td><td><code>setData  (String path,       byte[] data,       int version,       AsyncCallback.StatCallback cb,       Object ctx)</code>The asynchronous version of setData.说明：该方法为异步更新方法</td></tr></tbody></table><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>想要更新的节点路径。</td></tr><tr><td>data[ ]</td><td>更新的内容</td></tr><tr><td>version</td><td>指定更新的数据版本</td></tr><tr><td>cb</td><td>异步回调函数</td></tr><tr><td>ctx</td><td>上下文对象</td></tr></tbody></table><h2 id="通过API删除节点"><a href="#通过API删除节点" class="headerlink" title="通过API删除节点"></a>通过API删除节点</h2><h3 id="API说明-1"><a href="#API说明-1" class="headerlink" title="API说明"></a>API说明</h3><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>delete  (String path,      int version)</code>Delete the node with the given path.</td></tr><tr><td><code>void</code></td><td><code>delete  (String path,      int version,      AsyncCallback.VoidCallback cb,      Object ctx)</code>The asynchronous version of delete.</td></tr></tbody></table><hr><h2 id="通过API判断节点是否存在"><a href="#通过API判断节点是否存在" class="headerlink" title="通过API判断节点是否存在"></a>通过API判断节点是否存在</h2><h3 id="API说明-2"><a href="#API说明-2" class="headerlink" title="API说明"></a>API说明</h3><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>Stat</code></td><td><code>exists  (String path,      boolean watch)</code>Return the stat of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>exists  (String path,      boolean watch,      AsyncCallback.StatCallback cb,      Object ctx)</code>The asynchronous version of exists.</td></tr><tr><td><code>Stat</code></td><td><code>exists  (String path,      Watcher watcher)</code>Return the stat of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>exists  (String path,      Watcher watcher,      AsyncCallback.StatCallback cb,      Object ctx)</code>The asynchronous version of exists.</td></tr></tbody></table><hr><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><h3 id="API说明-3"><a href="#API说明-3" class="headerlink" title="API说明"></a>API说明</h3><table><thead><tr><th>返回值</th><th>方法</th></tr></thead><tbody><tr><td><code>List</code></td><td><code>getACL  (String path,      Stat stat)</code>Return the ACL and stat of the node of the given path.</td></tr><tr><td><code>void</code></td><td><code>getACL  (String path,      Stat stat,      AsyncCallback.ACLCallback cb,      Object ctx)</code>The asynchronous version of getACL.</td></tr><tr><td><code>Stat</code></td><td><code>setACL  (String path,      List acl,      int version)</code>Set the ACL for the node of the given path if such a node exists and the given version matches the version of the node.</td></tr><tr><td><code>void</code></td><td><code>setACL  (String path,      List acl,      int version,      AsyncCallback.StatCallback cb,      Object ctx)</code>The asynchronous version of setACL.</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Zookeeper官方API文档 &lt;a href=&quot;http://zookeeper.apache.org/doc/r3.4.6/api/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://zookeeper.apache.org/doc/r3.4.6/api/index.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://wangran.me/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的安装部署与客户端使用</title>
    <link href="https://wangran.me/2016/07/23/zookeeper_deploy_and_client_using/"/>
    <id>https://wangran.me/2016/07/23/zookeeper_deploy_and_client_using/</id>
    <published>2016-07-22T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.577Z</updated>
    
    <content type="html"><![CDATA[<p>zookeeper官方网站: <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">http://zookeeper.apache.org/</a></p><h2 id="Zookeeper的安装与部署"><a href="#Zookeeper的安装与部署" class="headerlink" title="Zookeeper的安装与部署"></a>Zookeeper的安装与部署</h2><p>Zookeeper通过Java编写，因此运行前需要配置好JRE</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>zookeeper下载地址为<a href="http://mirrors.cnnic.cn/apache/zookeeper/" target="_blank" rel="noopener">http://mirrors.cnnic.cn/apache/zookeeper/</a><br><a id="more"></a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Zookeeper官方下载的文件为.tar.gz格式，我们只需解压即可完成安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf zookeeper-3.4.6.tar.gz</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="创建zoo-cfg文件"><a href="#创建zoo-cfg文件" class="headerlink" title="创建zoo.cfg文件"></a>创建zoo.cfg文件</h4><p>我们进入到解压后的Zookeeper目录下，找到/conf/zoo_sample.cfg文件，重命名为zoo.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># 基本事件单元，以毫秒为单位。它用来指示心跳，最小的 session 过期时间为两倍的 tickTime.</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 存储内存中数据库快照的位置，如果不设置参数，更新事务日志将被存储到默认位置</span><br><span class="line">dataDir=/home/yumao/zookeeper/data</span><br><span class="line">dataLogDir=/home/yumao/zookeeper/log</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 监听客户端连接的端口</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># 格式为server.id=host:port:port, 其中id为在dataDir目录下创建的myid文件中的数字, 每个机器的数字必须保证唯一, id的范围是1~255</span><br><span class="line"># 以下配置为单机配置</span><br><span class="line">server.1=127.0.0.1:2888:3888</span><br><span class="line"></span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure><h4 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h4><p>由于在zoo.cfg配置中指定了dataDir位置，进入dataDir=/home/yumao/zookeeper/data目录下，创建文件myid，内容为1</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:/opt/zookeeper-3.4.6/bin$ sudo ./zkServer.sh start</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure><h4 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:/opt/zookeeper-3.4.6/bin$ sudo ./zkServer.sh stop</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br><span class="line">yumao@ubuntu:/opt/zookeeper-3.4.6/bin$</span><br></pre></td></tr></table></figure><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>在/etc/profile文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#Set ZooKeeper Enviroment</span><br><span class="line">export ZOOKEEPER_HOME=/opt/zookeeper-3.4.6</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf</span><br></pre></td></tr></table></figure><hr><h2 id="Zookeeper客户端的使用"><a href="#Zookeeper客户端的使用" class="headerlink" title="Zookeeper客户端的使用"></a>Zookeeper客户端的使用</h2><h3 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkCli.sh</span><br></pre></td></tr></table></figure><p>注：在执行该脚本的时候，系统报了个错</p><blockquote><p>zkCli.sh: 81: /opt/zookeeper-3.4.6/bin/zkEnv.sh: Syntax error: “(“ unexpected (expecting “fi”)</p></blockquote><p>一般出现该问题是因为没有配置Zookeeper的环境变量，但还有一个问题是ubuntu本身的配置问题导致，执行以下命令后解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:/bin$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4 May 17 10:34 /bin/sh -&gt; dash</span><br><span class="line">yumao@ubuntu:/bin$ sudo ln -sf bash /bin/sh</span><br><span class="line">yumao@ubuntu:/bin$ ls -l /bin/sh</span><br><span class="line">lrwxrwxrwx 1 root root 4 Jul 26 03:23 /bin/sh -&gt; bash</span><br></pre></td></tr></table></figure><p>若客户端脚本成功启动，则系统控制台输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">yumao@ubuntu:/opt/zookeeper-3.4.6/bin$ sudo sh ./zkServer.sh start</span><br><span class="line">JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper-3.4.6/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line">yumao@ubuntu:/opt/zookeeper-3.4.6/bin$ sudo sh zkCli.sh </span><br><span class="line">Connecting to localhost:2181</span><br><span class="line">2016-07-26 03:29:22,781 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.6-1569965, built on 02/20/2014 09:09 GMT</span><br><span class="line">2016-07-26 03:29:22,789 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=ubuntu</span><br><span class="line">2016-07-26 03:29:22,790 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.7.0_51</span><br><span class="line">2016-07-26 03:29:22,791 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation</span><br><span class="line">2016-07-26 03:29:22,791 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/usr/jdk1.7.0_51/jre</span><br><span class="line">2016-07-26 03:29:22,791 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/opt/zookeeper-3.4.6/bin/../build/classes:/opt/zookeeper-3.4.6/bin/../build/lib/*.jar:/opt/zookeeper-3.4.6/bin/../lib/slf4j-log4j12-1.6.1.jar:/opt/zookeeper-3.4.6/bin/../lib/slf4j-api-1.6.1.jar:/opt/zookeeper-3.4.6/bin/../lib/netty-3.7.0.Final.jar:/opt/zookeeper-3.4.6/bin/../lib/log4j-1.2.16.jar:/opt/zookeeper-3.4.6/bin/../lib/jline-0.9.94.jar:/opt/zookeeper-3.4.6/bin/../zookeeper-3.4.6.jar:/opt/zookeeper-3.4.6/bin/../src/java/lib/*.jar:/opt/zookeeper-3.4.6/bin/../conf:$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</span><br><span class="line">2016-07-26 03:29:22,791 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line">2016-07-26 03:29:22,792 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/tmp</span><br><span class="line">2016-07-26 03:29:22,792 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=&lt;NA&gt;</span><br><span class="line">2016-07-26 03:29:22,792 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Linux</span><br><span class="line">2016-07-26 03:29:22,792 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=amd64</span><br><span class="line">2016-07-26 03:29:22,793 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=4.4.0-31-generic</span><br><span class="line">2016-07-26 03:29:22,793 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=root</span><br><span class="line">2016-07-26 03:29:22,793 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/root</span><br><span class="line">2016-07-26 03:29:22,793 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/opt/zookeeper-3.4.6/bin</span><br><span class="line">2016-07-26 03:29:22,794 [myid:] - INFO  [main:ZooKeeper@438] - Initiating client connection, connectString=localhost:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@4b4cab63</span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">JLine support is enabled</span><br><span class="line">2016-07-26 03:29:22,865 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@975] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">2016-07-26 03:29:22,887 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@852] - Socket connection established to localhost/127.0.0.1:2181, initiating session</span><br><span class="line">[zk: localhost:2181(CONNECTING) 0] 2016-07-26 03:29:22,936 [myid:] - INFO  [main-SendThread(localhost:2181):ClientCnxn$SendThread@1235] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x15626c0466b0000, negotiated timeout = 30000</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br></pre></td></tr></table></figure><p>若想以指定Zookeeper地址启动，则命令应输入</p><blockquote><p>sh zkCli.sh -server ip:port</p></blockquote><hr><h3 id="通过客户端创建一个Zookeeper节点"><a href="#通过客户端创建一个Zookeeper节点" class="headerlink" title="通过客户端创建一个Zookeeper节点"></a>通过客户端创建一个Zookeeper节点</h3><blockquote><p>create [-s]  [-e] path data acl</p></blockquote><p>其中 -s或-e分别指节点的特性，-s代表顺序节点，-e则代表临时节点。若不添加-e或-s参数，默认创建持久节点。</p><p>acl表示用来进行权限控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line">create /test_root test_data</span><br><span class="line">Created /test_root</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1]</span><br></pre></td></tr></table></figure><h3 id="读取Zookeeper节点"><a href="#读取Zookeeper节点" class="headerlink" title="读取Zookeeper节点"></a>读取Zookeeper节点</h3><h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>列出指定节点下的所有子节点。只能看到指定节点下的第一级的所有子节点。</p><blockquote><p>ls path [watch]</p></blockquote><p>case：在根节点下创建了/test_root持久节点后，使用ls命令查看根节点。然后再/test_root节点下创建了新的持久子节点1，再次使用ls命令查看根节点，结果无变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line">create /test_root test_data</span><br><span class="line">Created /test_root</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[test_root, dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create /test_root/1 test_data_1</span><br><span class="line">Created /test_root/1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[test_root, dubbo, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /test_root</span><br><span class="line">[1]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5]</span><br></pre></td></tr></table></figure><h4 id="get命令"><a href="#get命令" class="headerlink" title="get命令"></a>get命令</h4><p>获取指定节点数据内容和属性信息</p><blockquote><p>get path [watch]</p></blockquote><p>case：使用get命令查看根节点test_root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] get /test_root</span><br><span class="line">test_data</span><br><span class="line">cZxid = 0xbf</span><br><span class="line">ctime = Tue Jul 26 03:35:51 PDT 2016</span><br><span class="line">mZxid = 0xbf</span><br><span class="line">mtime = Tue Jul 26 03:35:51 PDT 2016</span><br><span class="line">pZxid = 0xc0</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6]</span><br></pre></td></tr></table></figure><h3 id="更新Zookeeper节点"><a href="#更新Zookeeper节点" class="headerlink" title="更新Zookeeper节点"></a>更新Zookeeper节点</h3><h4 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h4><blockquote><p>set path data [version]</p></blockquote><p>case: 将/test_root节点的值更新为luffy，注意更新后节点version的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] get /test_root</span><br><span class="line">test_data</span><br><span class="line">cZxid = 0xbf</span><br><span class="line">ctime = Tue Jul 26 03:35:51 PDT 2016</span><br><span class="line">mZxid = 0xbf</span><br><span class="line">mtime = Tue Jul 26 03:35:51 PDT 2016</span><br><span class="line">pZxid = 0xc0</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] set /test_root luffy</span><br><span class="line">cZxid = 0xbf</span><br><span class="line">ctime = Tue Jul 26 03:35:51 PDT 2016</span><br><span class="line">mZxid = 0xc3</span><br><span class="line">mtime = Tue Jul 26 19:24:32 PDT 2016</span><br><span class="line">pZxid = 0xc0</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5]</span><br></pre></td></tr></table></figure><h3 id="删除Zookeeper节点"><a href="#删除Zookeeper节点" class="headerlink" title="删除Zookeeper节点"></a>删除Zookeeper节点</h3><h4 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h4><blockquote><p>delete path [version]<br>注意，只能删除叶子节点。</p></blockquote><p>case: 将/test_root下的1节点删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /test_root</span><br><span class="line">[1]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] delete /test_root/1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] ls /test_root      </span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 8]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zookeeper官方网站: &lt;a href=&quot;http://zookeeper.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://zookeeper.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Zookeeper的安装与部署&quot;&gt;&lt;a href=&quot;#Zookeeper的安装与部署&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper的安装与部署&quot;&gt;&lt;/a&gt;Zookeeper的安装与部署&lt;/h2&gt;&lt;p&gt;Zookeeper通过Java编写，因此运行前需要配置好JRE&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;zookeeper下载地址为&lt;a href=&quot;http://mirrors.cnnic.cn/apache/zookeeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mirrors.cnnic.cn/apache/zookeeper/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://wangran.me/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习笔记二</title>
    <link href="https://wangran.me/2016/07/18/zookeeper_summary/"/>
    <id>https://wangran.me/2016/07/18/zookeeper_summary/</id>
    <published>2016-07-17T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>ZooKeeper没有沿用传统集群模式（主备模式，Master/Slave），而是采用了Leader、Follower、Observer三种角色。</p><ul><li>Leader 选举而来，为client提供读/写服务。</li><li>Follower 为client提供读服务，可参与选举。</li><li>Observer 为client提供读服务，不参与Leader选举，不参与写操作的“过半写成功”策略，通常用于提升集群读性能。<a id="more"></a></li></ul><hr><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><hr><h3 id="数据节点（Znode）"><a href="#数据节点（Znode）" class="headerlink" title="数据节点（Znode）"></a>数据节点（Znode）</h3><p>指数据模型（Znode Tree）中的数据单元</p><hr><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><hr><h3 id="事件监听器（Watcher）"><a href="#事件监听器（Watcher）" class="headerlink" title="事件监听器（Watcher）"></a>事件监听器（Watcher）</h3><hr><h3 id="ACL（Access-Control-Lists）"><a href="#ACL（Access-Control-Lists）" class="headerlink" title="ACL（Access Control Lists）"></a>ACL（Access Control Lists）</h3><p>ZooKeeper定义了5种权限：</p><ul><li>CREATE 创建子节点的权限</li><li>READ 获取节点数据和节点列表的权限</li><li>WRITE 更新节点数据的权限</li><li>DELETE 删除子节点的权限</li><li>ADMIN 设置节点ACL的权限</li></ul><hr><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZooKeeper原子消息广播协议（Zookeeper Atomic Broadcast）。<br>ZooKeeper并未采用Paxos，而是采用ZAB作为数据一致性的核心算法。</p><h3 id="ZAB协议两种基本模式"><a href="#ZAB协议两种基本模式" class="headerlink" title="ZAB协议两种基本模式"></a>ZAB协议两种基本模式</h3><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>  服务器启动、Leader服务器挂掉时进入该模式，选举产生新Leader服务器。<br>  当集群中有过半服务器（包含Leader）与Leader服务器完成状态同步（即数据同步）后，退出该模式。</p><h5 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h5><ul><li>ZAB协议需要确保已在Leader提交的事务最终被所有服务器提交。</li><li>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。</li></ul><h5 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h5><p>算法思路：确保已被Leader提交的事务Proposal，同时丢弃已被掉过的事务Proposal。<br>即保证选举出的Leader服务器拥有集群中ZXID最大的事务Proposal。</p><h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h5><p>Leader服务器通过确认事务日志中所有Proposal是否已被集群中过半的服务器提交，来判断是否完成数据同步。</p><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><h5 id="ZAB协议核心"><a href="#ZAB协议核心" class="headerlink" title="ZAB协议核心"></a>ZAB协议核心</h5><p>定义了可能改变ZooKeeper服务器数据状态的数据请求处理方式：<br><img src="/images/zookeeper/zab/2016_07_18_zab_message_broadcast.png" alt="zab_message_broadcast"></p><ul><li>Leader服务器收到事务请求后，生成事务Proposal，并为其分配事务ID（全局单调递增的ID，ZXID），放入队列中。</li><li>Follower服务器接收到Proposal后，以事务日志形式写入到本地磁盘，写入成功后Respone Leader服务器“Ack”。</li><li>当Leader服务器接收超过半数Follower服务器Ack响应，广播Commit消息发送给所有Follower服务器，Leader自身与收到Commit消息的Follower服务器会完成事务提交。</li></ul><p>基于TCP协议（FIFO）保证消息接收与发送的顺序性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h3 id=&quot;集群角色&quot;&gt;&lt;a href=&quot;#集群角色&quot; class=&quot;headerlink&quot; title=&quot;集群角色&quot;&gt;&lt;/a&gt;集群角色&lt;/h3&gt;&lt;p&gt;ZooKeeper没有沿用传统集群模式（主备模式，Master/Slave），而是采用了Leader、Follower、Observer三种角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader 选举而来，为client提供读/写服务。&lt;/li&gt;
&lt;li&gt;Follower 为client提供读服务，可参与选举。&lt;/li&gt;
&lt;li&gt;Observer 为client提供读服务，不参与Leader选举，不参与写操作的“过半写成功”策略，通常用于提升集群读性能。
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://wangran.me/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习笔记二</title>
    <link href="https://wangran.me/2016/07/18/zookeeper-02/"/>
    <id>https://wangran.me/2016/07/18/zookeeper-02/</id>
    <published>2016-07-17T16:00:00.000Z</published>
    <updated>2018-10-09T11:21:35.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h3><p>ZooKeeper没有沿用传统集群模式（主备模式，Master/Slave），而是采用了Leader、Follower、Observer三种角色。</p><ul><li>Leader 选举而来，为client提供读/写服务。</li><li>Follower 为client提供读服务，可参与选举。</li><li>Observer 为client提供读服务，不参与Leader选举，不参与写操作的“过半写成功”策略，通常用于提升集群读性能。<a id="more"></a></li></ul><hr><h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><hr><h3 id="数据节点（Znode）"><a href="#数据节点（Znode）" class="headerlink" title="数据节点（Znode）"></a>数据节点（Znode）</h3><p>指数据模型（Znode Tree）中的数据单元</p><hr><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><hr><h3 id="事件监听器（Watcher）"><a href="#事件监听器（Watcher）" class="headerlink" title="事件监听器（Watcher）"></a>事件监听器（Watcher）</h3><hr><h3 id="ACL（Access-Control-Lists）"><a href="#ACL（Access-Control-Lists）" class="headerlink" title="ACL（Access Control Lists）"></a>ACL（Access Control Lists）</h3><p>ZooKeeper定义了5种权限：</p><ul><li>CREATE 创建子节点的权限</li><li>READ 获取节点数据和节点列表的权限</li><li>WRITE 更新节点数据的权限</li><li>DELETE 删除子节点的权限</li><li>ADMIN 设置节点ACL的权限</li></ul><hr><h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZooKeeper原子消息广播协议（Zookeeper Atomic Broadcast）。<br>ZooKeeper并未采用Paxos，而是采用ZAB作为数据一致性的核心算法。</p><h3 id="ZAB协议两种基本模式"><a href="#ZAB协议两种基本模式" class="headerlink" title="ZAB协议两种基本模式"></a>ZAB协议两种基本模式</h3><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>  服务器启动、Leader服务器挂掉时进入该模式，选举产生新Leader服务器。<br>  当集群中有过半服务器（包含Leader）与Leader服务器完成状态同步（即数据同步）后，退出该模式。</p><h5 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h5><ul><li>ZAB协议需要确保已在Leader提交的事务最终被所有服务器提交。</li><li>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务。</li></ul><h5 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h5><p>算法思路：确保已被Leader提交的事务Proposal，同时丢弃已被掉过的事务Proposal。<br>即保证选举出的Leader服务器拥有集群中ZXID最大的事务Proposal。</p><h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h5><p>Leader服务器通过确认事务日志中所有Proposal是否已被集群中过半的服务器提交，来判断是否完成数据同步。</p><h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><h5 id="ZAB协议核心"><a href="#ZAB协议核心" class="headerlink" title="ZAB协议核心"></a>ZAB协议核心</h5><p>定义了可能改变ZooKeeper服务器数据状态的数据请求处理方式：<br><img src="/images/zookeeper/zab/2016_07_18_zab_message_broadcast.png" alt="zab_message_broadcast"></p><ul><li>Leader服务器收到事务请求后，生成事务Proposal，并为其分配事务ID（全局单调递增的ID，ZXID），放入队列中。</li><li>Follower服务器接收到Proposal后，以事务日志形式写入到本地磁盘，写入成功后Respone Leader服务器“Ack”。</li><li>当Leader服务器接收超过半数Follower服务器Ack响应，广播Commit消息发送给所有Follower服务器，Leader自身与收到Commit消息的Follower服务器会完成事务提交。</li></ul><p>基于TCP协议（FIFO）保证消息接收与发送的顺序性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h3 id=&quot;集群角色&quot;&gt;&lt;a href=&quot;#集群角色&quot; class=&quot;headerlink&quot; title=&quot;集群角色&quot;&gt;&lt;/a&gt;集群角色&lt;/h3&gt;&lt;p&gt;ZooKeeper没有沿用传统集群模式（主备模式，Master/Slave），而是采用了Leader、Follower、Observer三种角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader 选举而来，为client提供读/写服务。&lt;/li&gt;
&lt;li&gt;Follower 为client提供读服务，可参与选举。&lt;/li&gt;
&lt;li&gt;Observer 为client提供读服务，不参与Leader选举，不参与写操作的“过半写成功”策略，通常用于提升集群读性能。
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper ZAB" scheme="https://wangran.me/tags/Zookeeper-ZAB/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习笔记一之Paxos算法</title>
    <link href="https://wangran.me/2016/07/10/zookeeper-01/"/>
    <id>https://wangran.me/2016/07/10/zookeeper-01/</id>
    <published>2016-07-09T16:00:00.000Z</published>
    <updated>2018-10-09T11:21:35.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1990年提出的一种基于消息传递且具有高度容错性的一致性算法。<br><a id="more"></a></p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>假设有一组可以提出提案的进程集合，对于一个一致性算法来说需保证：</p><ul><li>提案只有一个会被选定</li><li>若没有提案提出，则没有被选定的提案</li><li>提案若被选定，进程可以获取提案信息</li></ul><p>分布式系统的【三态】：成功、失败、超时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;1990年提出的一种基于消息传递且具有高度容错性的一致性算法。&lt;br&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper Paxos" scheme="https://wangran.me/tags/Zookeeper-Paxos/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper学习笔记一之Paxos算法</title>
    <link href="https://wangran.me/2016/07/10/zookeeper_paxos/"/>
    <id>https://wangran.me/2016/07/10/zookeeper_paxos/</id>
    <published>2016-07-09T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1990年提出的一种基于消息传递且具有高度容错性的一致性算法。<br><a id="more"></a></p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>假设有一组可以提出提案的进程集合，对于一个一致性算法来说需保证：</p><ul><li>提案只有一个会被选定</li><li>若没有提案提出，则没有被选定的提案</li><li>提案若被选定，进程可以获取提案信息</li></ul><p>分布式系统的【三态】：成功、失败、超时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;1990年提出的一种基于消息传递且具有高度容错性的一致性算法。&lt;br&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://wangran.me/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="https://wangran.me/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>TCP长连接与短连接的区别</title>
    <link href="https://wangran.me/2016/07/03/tcp-connection/"/>
    <id>https://wangran.me/2016/07/03/tcp-connection/</id>
    <published>2016-07-02T16:00:00.000Z</published>
    <updated>2018-10-09T11:21:35.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><a id="more"></a><p>经典的三次握手示意图：</p><p><img src="/images/networking_protocol/tcp/2016_07_03_01.jpg" alt="tcp_connection"></p><p>经典的四次握手关闭图：<br><img src="/images/networking_protocol/tcp/2016_07_03_02.jpg" alt="tcp_connection"></p><hr><h2 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h2><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><hr><h2 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h2><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li><li>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</li></ul><p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><hr><p>本文转自<a href="http://www.cnblogs.com/beifei/archive/2011/06/26/2090611.html" target="_blank" rel="noopener">http://www.cnblogs.com/beifei/archive/2011/06/26/2090611.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP连接&quot;&gt;&lt;a href=&quot;#TCP连接&quot; class=&quot;headerlink&quot; title=&quot;TCP连接&quot;&gt;&lt;/a&gt;TCP连接&lt;/h2&gt;&lt;p&gt;当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。&lt;/p&gt;
    
    </summary>
    
      <category term="TCP" scheme="https://wangran.me/categories/TCP/"/>
    
    
      <category term="TCP Connection TCP连接" scheme="https://wangran.me/tags/TCP-Connection-TCP%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>TCP长连接与短连接的区别</title>
    <link href="https://wangran.me/2016/07/03/tcp_connection/"/>
    <id>https://wangran.me/2016/07/03/tcp_connection/</id>
    <published>2016-07-02T16:00:00.000Z</published>
    <updated>2018-10-09T11:25:29.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。</p><a id="more"></a><p>经典的三次握手示意图：</p><p><img src="/images/networking_protocol/tcp/2016_07_03_01.jpg" alt="tcp_connection"></p><p>经典的四次握手关闭图：<br><img src="/images/networking_protocol/tcp/2016_07_03_02.jpg" alt="tcp_connection"></p><hr><h2 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h2><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在client/server间传递一次读写操作</p><p>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><hr><h2 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h2><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>首先说一下TCP/IP详解上讲到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p><ul><li>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</li><li>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</li><li>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</li><li>客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</li><li>从上面可以看出，TCP保活功能主要为探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</li></ul><p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><hr><p>本文转自<a href="http://www.cnblogs.com/beifei/archive/2011/06/26/2090611.html" target="_blank" rel="noopener">http://www.cnblogs.com/beifei/archive/2011/06/26/2090611.html</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP连接&quot;&gt;&lt;a href=&quot;#TCP连接&quot; class=&quot;headerlink&quot; title=&quot;TCP连接&quot;&gt;&lt;/a&gt;TCP连接&lt;/h2&gt;&lt;p&gt;当网络通信时采用TCP协议时，在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立是需要三次握手的，而释放则需要4次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。&lt;/p&gt;
    
    </summary>
    
      <category term="TCP" scheme="https://wangran.me/categories/TCP/"/>
    
    
      <category term="TCP" scheme="https://wangran.me/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>数据库学习笔记 - 数据库保护</title>
    <link href="https://wangran.me/2016/05/22/db_trans/"/>
    <id>https://wangran.me/2016/05/22/db_trans/</id>
    <published>2016-05-21T16:00:00.000Z</published>
    <updated>2018-10-19T07:40:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事务（Transaction）"><a href="#什么是事务（Transaction）" class="headerlink" title="什么是事务（Transaction）"></a>什么是事务（Transaction）</h2><p>事务是用户定义的数据操作系列，这些操作可作为一个完整的工作单元（数据库的逻辑工作单位）。<br><a id="more"></a></p><hr><h2 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h2><ul><li>原子性（Atomicity）事务中的操作要么都做，要么都不做。</li><li>一致性（Consistency）只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。</li><li>隔离性（Isolation）数据库中一个事务的执行不能被其他事务干扰。</li><li>持久性（Durability）事务一旦提交，其对数据库中数据的改变就是永久的。</li></ul><hr><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>并发问题导致的异常情况归类如下：</p><h4 id="丢失更新（Lost-Update）"><a href="#丢失更新（Lost-Update）" class="headerlink" title="丢失更新（Lost Update）"></a>丢失更新（Lost Update）</h4><p>两个事务都同时更新一行数据，第一个事务的提交结果被第二个事务的提交结果破坏。</p><p><img src="/images/db/transaction/2016_05_26_lost_update.png" alt="lost_update"></p><h4 id="脏读（Dirty-Reads）"><a href="#脏读（Dirty-Reads）" class="headerlink" title="脏读（Dirty Reads）"></a>脏读（Dirty Reads）</h4><p>一个事务读了某个失败事务运行过程中的数据。</p><p><img src="/images/db/transaction/2016_05_26_dirty_reads.png" alt="ldirty_reads"></p><h4 id="不可重复读（Non-repeatable-Reads）"><a href="#不可重复读（Non-repeatable-Reads）" class="headerlink" title="不可重复读（Non-repeatable Reads）"></a>不可重复读（Non-repeatable Reads）</h4><p>一个事务对同一行数据重复读取两次，但是却得到了不同的结果。</p><p><img src="/images/db/transaction/2016_05_26_non_repeatable_reads.png" alt="non_repeatable_reads"></p><h4 id="幻读（Phantom-Reads）"><a href="#幻读（Phantom-Reads）" class="headerlink" title="幻读（Phantom Reads）"></a>幻读（Phantom Reads）</h4><p>幻读实际属于不可重复读的范畴。它指当事务T1按照一定条件读取某些数据，事务T2对其中部分记录做了删除或更新操作，当事务T1再次以相同条件读取数据时，发现少或多了某些记录。</p><hr><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h4 id="未授权读取（Read-Uncommitted）"><a href="#未授权读取（Read-Uncommitted）" class="headerlink" title="未授权读取（Read Uncommitted）"></a>未授权读取（Read Uncommitted）</h4><p>也称读未提交，隔离级别最低，允许脏读。</p><h4 id="授权读取（Read-Committed）"><a href="#授权读取（Read-Committed）" class="headerlink" title="授权读取（Read Committed）"></a>授权读取（Read Committed）</h4><p>也称读已提交，允许不可重复读。</p><h4 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h4><p>允许出现幻读。</p><h4 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h4><p>最严格的事务隔离级别，要求所有事务都被串行执行。</p><p><img src="/images/db/transaction/2016_05_26_transaction_isolation_level.png" alt="transaction_isolation_level"></p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未授权读取</td><td>存在</td><td>不可以</td><td>存在</td></tr><tr><td>授权读取</td><td>不存在</td><td>不可以</td><td>存在</td></tr><tr><td>可重复读取</td><td>不存在</td><td>可以</td><td>存在</td></tr><tr><td>串行化</td><td>不存在</td><td>可以</td><td>不存在</td></tr></tbody></table><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），最多只能同时满足其中两项。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>协调者：统一调度所有分布式节点执行逻辑组件。<br>参与者：被协调者调度的分布式节点。</p><h2 id="2PC二阶段提交协议（Two-Phase-Commit）"><a href="#2PC二阶段提交协议（Two-Phase-Commit）" class="headerlink" title="2PC二阶段提交协议（Two-Phase Commit）"></a>2PC二阶段提交协议（Two-Phase Commit）</h2><h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="悲观锁（Pessimistic-Concurrency-Control，-PCC）"><a href="#悲观锁（Pessimistic-Concurrency-Control，-PCC）" class="headerlink" title="悲观锁（Pessimistic Concurrency Control， PCC）"></a>悲观锁（Pessimistic Concurrency Control， PCC）</h2><p>又称排他锁，若事务T1使用悲观锁对数据进行处理，则处理完成前，其他事务均不能对数据进行更新操作。</p><h2 id="乐观锁-（Optimistic-Concurrency-Control，-OCC）"><a href="#乐观锁-（Optimistic-Concurrency-Control，-OCC）" class="headerlink" title="乐观锁 （Optimistic Concurrency Control， OCC）"></a>乐观锁 （Optimistic Concurrency Control， OCC）</h2><p>乐观锁事务控制分为三阶段，分别是：数据读取、写入校验、数据写入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是事务（Transaction）&quot;&gt;&lt;a href=&quot;#什么是事务（Transaction）&quot; class=&quot;headerlink&quot; title=&quot;什么是事务（Transaction）&quot;&gt;&lt;/a&gt;什么是事务（Transaction）&lt;/h2&gt;&lt;p&gt;事务是用户定义的数据操作系列，这些操作可作为一个完整的工作单元（数据库的逻辑工作单位）。&lt;br&gt;
    
    </summary>
    
      <category term="Database" scheme="https://wangran.me/categories/Database/"/>
    
    
      <category term="数据库" scheme="https://wangran.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
